"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/profile/page",{

/***/ "(app-pages-browser)/./src/hooks/useVendorProfile.ts":
/*!***************************************!*\
  !*** ./src/hooks/useVendorProfile.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useVendorProfile: () => (/* binding */ useVendorProfile)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _contexts_AuthContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/contexts/AuthContext */ \"(app-pages-browser)/./src/contexts/AuthContext.tsx\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n\n\n\nfunction useVendorProfile() {\n    const { user } = (0,_contexts_AuthContext__WEBPACK_IMPORTED_MODULE_1__.useAuth)();\n    const [profile, setProfile] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [contacts, setContacts] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [locations, setLocations] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchProfile = async ()=>{\n        if (!user) {\n            setLoading(false);\n            return;\n        }\n        try {\n            // First check if user is a vendor by querying their profile\n            const supabase = (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.createClientComponentClient)();\n            const { data: userProfile, error: userProfileError } = await supabase.from(\"profiles\").select(\"user_type\").eq(\"id\", user.id).single();\n            if (userProfileError) {\n                console.error(\"Error fetching user profile:\", userProfileError);\n                setError(\"Failed to verify user type\");\n                setLoading(false);\n                return;\n            }\n            // Only proceed if user is a vendor\n            if (userProfile.user_type !== \"vendor\") {\n                console.log(\"User is not a vendor, skipping vendor profile fetch\");\n                setProfile(null);\n                setContacts([]);\n                setLocations([]);\n                setLoading(false);\n                return;\n            }\n            // Now fetch vendor profile with retry logic for timing issues\n            let profileData = null;\n            let vendorProfileError = null;\n            const maxRetries = 3;\n            const retryDelay = 1000;\n            for(let attempt = 1; attempt <= maxRetries; attempt++){\n                const { data, error } = await supabase.from(\"vendor_profiles\").select(\"*\").eq(\"user_id\", user.id).single();\n                profileData = data;\n                profileError = error;\n                if (profileError) {\n                    var _profileError_message;\n                    console.error(\"Error fetching vendor profile (attempt \".concat(attempt, \"/\").concat(maxRetries, \"):\"), profileError);\n                    // If vendor profile doesn't exist, that's expected for new vendors\n                    if (profileError.code === 'PGRST116') {\n                        console.log(\"Vendor profile doesn't exist yet - this is normal for new vendors\");\n                        setProfile(null);\n                        setContacts([]);\n                        setLocations([]);\n                        setError(null);\n                        setLoading(false);\n                        return;\n                    }\n                    // If this is a 406 error and we have retries left, wait and try again\n                    if (((_profileError_message = profileError.message) === null || _profileError_message === void 0 ? void 0 : _profileError_message.includes('406')) && attempt < maxRetries) {\n                        console.log(\"Received 406 error, retrying in \".concat(retryDelay, \"ms (attempt \").concat(attempt, \"/\").concat(maxRetries, \")\"));\n                        await new Promise((resolve)=>setTimeout(resolve, retryDelay));\n                        continue;\n                    }\n                    break;\n                } else {\n                    break;\n                }\n            }\n            if (profileError) {\n                console.error(\"Final error fetching vendor profile:\", JSON.stringify(profileError, null, 2));\n                setError(\"Failed to load profile data. Please try refreshing the page.\");\n                setLoading(false);\n                return;\n            }\n            setProfile(profileData);\n            // Fetch vendor contacts\n            const { data: contactsData, error: contactsError } = await supabase.from(\"vendor_contacts\").select(\"*\").eq(\"vendor_id\", profileData.id).order(\"is_primary\", {\n                ascending: false\n            });\n            if (contactsError) {\n                console.error(\"Error fetching vendor contacts:\", contactsError);\n            } else {\n                setContacts(contactsData || []);\n            }\n            // Fetch vendor locations\n            const { data: locationsData, error: locationsError } = await supabase.from(\"vendor_locations\").select(\"*\").eq(\"vendor_id\", profileData.id);\n            if (locationsError) {\n                console.error(\"Error fetching vendor locations:\", locationsError);\n            } else {\n                setLocations(locationsData || []);\n            }\n        } catch (err) {\n            console.error(\"Error in fetchProfile:\", err);\n            setError(\"An unexpected error occurred\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    const saveProfile = async (data)=>{\n        if (!user) {\n            return {\n                success: false,\n                error: \"No user found\"\n            };\n        }\n        try {\n            const supabase = (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.createClientComponentClient)();\n            let vendorProfileId;\n            if (!profile) {\n                // No profile exists, create one\n                console.log(\"No vendor profile found, creating new one...\");\n                // Generate unique slug for the vendor\n                let slug;\n                try {\n                    const { generateUniqueSlug } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_lib_slug-utils_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/slug-utils */ \"(app-pages-browser)/./src/lib/slug-utils.ts\"));\n                    slug = await generateUniqueSlug(data.business_name);\n                } catch (slugError) {\n                    console.warn('Failed to generate slug, creating vendor without slug:', slugError);\n                // Continue without slug - it will use ID for routing\n                }\n                const { data: newProfile, error: createError } = await supabase.from(\"vendor_profiles\").insert({\n                    user_id: user.id,\n                    business_name: data.business_name,\n                    ...slug && {\n                        slug\n                    },\n                    description: data.description,\n                    business_category: data.business_category,\n                    event_types: data.event_types,\n                    logo_url: data.logo_url\n                }).select().single();\n                if (createError) {\n                    console.error(\"Failed to create vendor profile:\", createError);\n                    return {\n                        success: false,\n                        error: \"Failed to create profile\"\n                    };\n                }\n                vendorProfileId = newProfile.id;\n                console.log(\"Vendor profile created with ID:\", vendorProfileId);\n            } else {\n                // Profile exists, update it\n                vendorProfileId = profile.id;\n                console.log(\"Updating existing vendor profile...\");\n                // Check if business name changed and regenerate slug if needed\n                let updateData = {\n                    business_name: data.business_name,\n                    description: data.description,\n                    business_category: data.business_category,\n                    event_types: data.event_types,\n                    logo_url: data.logo_url,\n                    updated_at: new Date().toISOString()\n                };\n                if (profile.business_name !== data.business_name) {\n                    // Business name changed, regenerate slug\n                    try {\n                        const { generateUniqueSlug } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_lib_slug-utils_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/slug-utils */ \"(app-pages-browser)/./src/lib/slug-utils.ts\"));\n                        const newSlug = await generateUniqueSlug(data.business_name, profile.slug || undefined);\n                        updateData.slug = newSlug;\n                        console.log(\"Business name changed, regenerating slug: \".concat(newSlug));\n                    } catch (slugError) {\n                        console.warn('Failed to regenerate slug, keeping existing slug:', slugError);\n                    // Keep existing slug or don't update it\n                    }\n                }\n                const { data: updateResult, error: profileError1 } = await supabase.from(\"vendor_profiles\").update(updateData).eq(\"id\", profile.id).select();\n                if (profileError1) {\n                    return {\n                        success: false,\n                        error: \"Failed to update profile\"\n                    };\n                }\n            }\n            console.log(\"🗑️ Deleting existing contacts and locations...\");\n            // Delete contacts first (only if profile existed before)\n            if (profile) {\n                const { error: deleteContactsError } = await supabase.from(\"vendor_contacts\").delete().eq(\"vendor_id\", profile.id);\n                console.log(\"📞 Contacts delete error:\", deleteContactsError);\n                if (deleteContactsError) {\n                    console.log(\"❌ Failed to delete contacts:\", deleteContactsError);\n                    return {\n                        success: false,\n                        error: \"Failed to delete existing contacts\"\n                    };\n                }\n                console.log(\"✅ Contacts deleted successfully\");\n                // Delete locations\n                const { error: deleteLocationsError } = await supabase.from(\"vendor_locations\").delete().eq(\"vendor_id\", profile.id);\n                console.log(\"📍 Locations delete error:\", deleteLocationsError);\n                if (deleteLocationsError) {\n                    console.log(\"❌ Failed to delete locations:\", deleteLocationsError);\n                    return {\n                        success: false,\n                        error: \"Failed to delete existing locations\"\n                    };\n                }\n                console.log(\"✅ Locations deleted successfully\");\n            }\n            console.log(\"📞 Inserting new contacts...\");\n            // Insert new contacts\n            if (data.contacts.length > 0) {\n                console.log(\"📋 Contacts to insert:\", data.contacts);\n                const { error: contactsError } = await supabase.from(\"vendor_contacts\").insert(data.contacts.map((contact)=>({\n                        vendor_id: vendorProfileId,\n                        contact_type: contact.contact_type,\n                        contact_value: contact.contact_value,\n                        is_primary: contact.is_primary\n                    })));\n                console.log(\"📞 Contacts insert error:\", contactsError);\n                if (contactsError) {\n                    console.log(\"❌ Failed to insert contacts:\", contactsError);\n                    return {\n                        success: false,\n                        error: \"Failed to update contacts\"\n                    };\n                }\n                console.log(\"✅ Contacts inserted successfully\");\n            } else {\n                console.log(\"ℹ️ No contacts to insert\");\n            }\n            console.log(\"📍 Inserting new locations...\");\n            // Insert new locations\n            if (data.locations.length > 0) {\n                console.log(\"🗺️ Locations to insert:\", data.locations);\n                // Validate location values\n                const validLocations = [\n                    \"nicosia\",\n                    \"limassol\",\n                    \"larnaca\",\n                    \"paphos\",\n                    \"platres\",\n                    \"paralimni_ayia_napa\",\n                    \"whole_cyprus\"\n                ];\n                const invalidLocations = data.locations.filter((location)=>!validLocations.includes(location));\n                if (invalidLocations.length > 0) {\n                    console.log(\"❌ Invalid location values:\", invalidLocations);\n                    return {\n                        success: false,\n                        error: \"Invalid location values: \".concat(invalidLocations.join(\", \"))\n                    };\n                }\n                const locationData = data.locations.map((location)=>({\n                        vendor_id: vendorProfileId,\n                        location: location\n                    }));\n                console.log(\"🗺️ Location data to insert:\", locationData);\n                const { data: insertedLocations, error: locationsError } = await supabase.from(\"vendor_locations\").insert(locationData).select();\n                console.log(\"📍 Locations insert error:\", locationsError);\n                console.log(\"📍 Inserted locations:\", insertedLocations);\n                if (locationsError) {\n                    console.log(\"❌ Failed to insert locations:\", locationsError);\n                    return {\n                        success: false,\n                        error: \"Failed to update locations\"\n                    };\n                }\n                console.log(\"✅ Locations inserted successfully\");\n            } else {\n                console.log(\"ℹ️ No locations to insert\");\n            }\n            console.log(\"🔄 Refetching profile data...\");\n            // Refetch data to update the UI\n            await fetchProfile();\n            console.log(\"🎉 Profile save completed successfully!\");\n            return {\n                success: true\n            };\n        } catch (err) {\n            console.log(\"💥 Exception in saveProfile:\", err);\n            return {\n                success: false,\n                error: \"An unexpected error occurred\"\n            };\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useVendorProfile.useEffect\": ()=>{\n            fetchProfile();\n        }\n    }[\"useVendorProfile.useEffect\"], [\n        user\n    ]);\n    return {\n        profile,\n        contacts,\n        locations,\n        loading,\n        error,\n        refetch: fetchProfile,\n        saveProfile\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VWZW5kb3JQcm9maWxlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTRDO0FBQ0s7QUFDc0I7QUFxRGhFLFNBQVNJO0lBQ2QsTUFBTSxFQUFFQyxJQUFJLEVBQUUsR0FBR0gsOERBQU9BO0lBQ3hCLE1BQU0sQ0FBQ0ksU0FBU0MsV0FBVyxHQUFHUCwrQ0FBUUEsQ0FBdUI7SUFDN0QsTUFBTSxDQUFDUSxVQUFVQyxZQUFZLEdBQUdULCtDQUFRQSxDQUFrQixFQUFFO0lBQzVELE1BQU0sQ0FBQ1UsV0FBV0MsYUFBYSxHQUFHWCwrQ0FBUUEsQ0FBbUIsRUFBRTtJQUMvRCxNQUFNLENBQUNZLFNBQVNDLFdBQVcsR0FBR2IsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDYyxPQUFPQyxTQUFTLEdBQUdmLCtDQUFRQSxDQUFnQjtJQUVsRCxNQUFNZ0IsZUFBZTtRQUNuQixJQUFJLENBQUNYLE1BQU07WUFDVFEsV0FBVztZQUNYO1FBQ0Y7UUFFQSxJQUFJO1lBQ0YsNERBQTREO1lBQzVELE1BQU1JLFdBQVdkLDBFQUEyQkE7WUFDNUMsTUFBTSxFQUFFZSxNQUFNQyxXQUFXLEVBQUVMLE9BQU9NLGdCQUFnQixFQUFFLEdBQUcsTUFBTUgsU0FDMURJLElBQUksQ0FBQyxZQUNMQyxNQUFNLENBQUMsYUFDUEMsRUFBRSxDQUFDLE1BQU1sQixLQUFLbUIsRUFBRSxFQUNoQkMsTUFBTTtZQUVULElBQUlMLGtCQUFrQjtnQkFDcEJNLFFBQVFaLEtBQUssQ0FBQyxnQ0FBZ0NNO2dCQUM5Q0wsU0FBUztnQkFDVEYsV0FBVztnQkFDWDtZQUNGO1lBRUEsbUNBQW1DO1lBQ25DLElBQUlNLFlBQVlRLFNBQVMsS0FBSyxVQUFVO2dCQUN0Q0QsUUFBUUUsR0FBRyxDQUFDO2dCQUNackIsV0FBVztnQkFDWEUsWUFBWSxFQUFFO2dCQUNkRSxhQUFhLEVBQUU7Z0JBQ2ZFLFdBQVc7Z0JBQ1g7WUFDRjtZQUVBLDhEQUE4RDtZQUNo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O1lBRVosZ0NBQWdDO1lBQ2hDLE1BQU1aO1lBRU5VLFFBQVFFLEdBQUcsQ0FBQztZQUNaLE9BQU87Z0JBQUV1QixTQUFTO1lBQUs7UUFDekIsRUFBRSxPQUFPRixLQUFLO1lBQ1p2QixRQUFRRSxHQUFHLENBQUMsZ0NBQWdDcUI7WUFDNUMsT0FBTztnQkFBRUUsU0FBUztnQkFBT3JDLE9BQU87WUFBK0I7UUFDakU7SUFDRjtJQUVBYixnREFBU0E7c0NBQUM7WUFDUmU7UUFDRjtxQ0FBRztRQUFDWDtLQUFLO0lBRVQsT0FBTztRQUNMQztRQUNBRTtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBNkUsU0FBUzNFO1FBQ1RrQztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXZpZGJhbGlhbi9EZXNrdG9wL21vbWVudG1vaS12b2lkL3NyYy9ob29rcy91c2VWZW5kb3JQcm9maWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUF1dGggfSBmcm9tIFwiQC9jb250ZXh0cy9BdXRoQ29udGV4dFwiO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50Q29tcG9uZW50Q2xpZW50LCBzdXBhYmFzZSB9IGZyb20gXCJAL2xpYi9zdXBhYmFzZVwiO1xuXG5pbnRlcmZhY2UgVmVuZG9yUHJvZmlsZSB7XG4gIGlkOiBzdHJpbmc7XG4gIHVzZXJfaWQ6IHN0cmluZztcbiAgc2x1Zzogc3RyaW5nIHwgbnVsbDtcbiAgYnVzaW5lc3NfbmFtZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nIHwgbnVsbDtcbiAgbG9nb191cmw6IHN0cmluZyB8IG51bGw7XG4gIHZlcmlmaWVkOiBib29sZWFuO1xuICBidXNpbmVzc19jYXRlZ29yeTogc3RyaW5nO1xuICBldmVudF90eXBlczogc3RyaW5nW107XG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgdXBkYXRlZF9hdDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVmVuZG9yQ29udGFjdCB7XG4gIGlkOiBzdHJpbmc7XG4gIHZlbmRvcl9pZDogc3RyaW5nO1xuICBjb250YWN0X3R5cGU6IFwiZW1haWxcIiB8IFwicGhvbmVcIjtcbiAgY29udGFjdF92YWx1ZTogc3RyaW5nO1xuICBpc19wcmltYXJ5OiBib29sZWFuO1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBWZW5kb3JMb2NhdGlvbiB7XG4gIGlkOiBzdHJpbmc7XG4gIHZlbmRvcl9pZDogc3RyaW5nO1xuICBsb2NhdGlvbjogc3RyaW5nO1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBVc2VWZW5kb3JQcm9maWxlUmV0dXJuIHtcbiAgcHJvZmlsZTogVmVuZG9yUHJvZmlsZSB8IG51bGw7XG4gIGNvbnRhY3RzOiBWZW5kb3JDb250YWN0W107XG4gIGxvY2F0aW9uczogVmVuZG9yTG9jYXRpb25bXTtcbiAgbG9hZGluZzogYm9vbGVhbjtcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XG4gIHJlZmV0Y2g6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIHNhdmVQcm9maWxlOiAoZGF0YToge1xuICAgIGJ1c2luZXNzX25hbWU6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgIGJ1c2luZXNzX2NhdGVnb3J5OiBzdHJpbmc7XG4gICAgZXZlbnRfdHlwZXM6IHN0cmluZ1tdO1xuICAgIGNvbnRhY3RzOiBBcnJheTx7XG4gICAgICBjb250YWN0X3R5cGU6IFwiZW1haWxcIiB8IFwicGhvbmVcIjtcbiAgICAgIGNvbnRhY3RfdmFsdWU6IHN0cmluZztcbiAgICAgIGlzX3ByaW1hcnk6IGJvb2xlYW47XG4gICAgfT47XG4gICAgbG9jYXRpb25zOiBzdHJpbmdbXTtcbiAgfSkgPT4gUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVmVuZG9yUHJvZmlsZSgpOiBVc2VWZW5kb3JQcm9maWxlUmV0dXJuIHtcbiAgY29uc3QgeyB1c2VyIH0gPSB1c2VBdXRoKCk7XG4gIGNvbnN0IFtwcm9maWxlLCBzZXRQcm9maWxlXSA9IHVzZVN0YXRlPFZlbmRvclByb2ZpbGUgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2NvbnRhY3RzLCBzZXRDb250YWN0c10gPSB1c2VTdGF0ZTxWZW5kb3JDb250YWN0W10+KFtdKTtcbiAgY29uc3QgW2xvY2F0aW9ucywgc2V0TG9jYXRpb25zXSA9IHVzZVN0YXRlPFZlbmRvckxvY2F0aW9uW10+KFtdKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3QgZmV0Y2hQcm9maWxlID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghdXNlcikge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHVzZXIgaXMgYSB2ZW5kb3IgYnkgcXVlcnlpbmcgdGhlaXIgcHJvZmlsZVxuICAgICAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnRDb21wb25lbnRDbGllbnQoKTtcbiAgICAgIGNvbnN0IHsgZGF0YTogdXNlclByb2ZpbGUsIGVycm9yOiB1c2VyUHJvZmlsZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbShcInByb2ZpbGVzXCIpXG4gICAgICAgIC5zZWxlY3QoXCJ1c2VyX3R5cGVcIilcbiAgICAgICAgLmVxKFwiaWRcIiwgdXNlci5pZClcbiAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICBpZiAodXNlclByb2ZpbGVFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgdXNlciBwcm9maWxlOlwiLCB1c2VyUHJvZmlsZUVycm9yKTtcbiAgICAgICAgc2V0RXJyb3IoXCJGYWlsZWQgdG8gdmVyaWZ5IHVzZXIgdHlwZVwiKTtcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gT25seSBwcm9jZWVkIGlmIHVzZXIgaXMgYSB2ZW5kb3JcbiAgICAgIGlmICh1c2VyUHJvZmlsZS51c2VyX3R5cGUgIT09IFwidmVuZG9yXCIpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJVc2VyIGlzIG5vdCBhIHZlbmRvciwgc2tpcHBpbmcgdmVuZG9yIHByb2ZpbGUgZmV0Y2hcIik7XG4gICAgICAgIHNldFByb2ZpbGUobnVsbCk7XG4gICAgICAgIHNldENvbnRhY3RzKFtdKTtcbiAgICAgICAgc2V0TG9jYXRpb25zKFtdKTtcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTm93IGZldGNoIHZlbmRvciBwcm9maWxlIHdpdGggcmV0cnkgbG9naWMgZm9yIHRpbWluZyBpc3N1ZXNcbiAgICBsZXQgcHJvZmlsZURhdGEgPSBudWxsO1xuICAgIGxldCB2ZW5kb3JQcm9maWxlRXJyb3I6IGFueSA9IG51bGw7XG4gICAgY29uc3QgbWF4UmV0cmllcyA9IDM7XG4gICAgY29uc3QgcmV0cnlEZWxheSA9IDEwMDA7XG5cbiAgICBmb3IgKGxldCBhdHRlbXB0ID0gMTsgYXR0ZW1wdCA8PSBtYXhSZXRyaWVzOyBhdHRlbXB0KyspIHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKFwidmVuZG9yX3Byb2ZpbGVzXCIpXG4gICAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAgIC5lcShcInVzZXJfaWRcIiwgdXNlci5pZClcbiAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICBwcm9maWxlRGF0YSA9IGRhdGE7XG4gICAgICBwcm9maWxlRXJyb3IgPSBlcnJvcjtcblxuICAgICAgaWYgKHByb2ZpbGVFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyB2ZW5kb3IgcHJvZmlsZSAoYXR0ZW1wdCAke2F0dGVtcHR9LyR7bWF4UmV0cmllc30pOmAsIHByb2ZpbGVFcnJvcik7XG5cbiAgICAgICAgLy8gSWYgdmVuZG9yIHByb2ZpbGUgZG9lc24ndCBleGlzdCwgdGhhdCdzIGV4cGVjdGVkIGZvciBuZXcgdmVuZG9yc1xuICAgICAgICBpZiAocHJvZmlsZUVycm9yLmNvZGUgPT09ICdQR1JTVDExNicpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlZlbmRvciBwcm9maWxlIGRvZXNuJ3QgZXhpc3QgeWV0IC0gdGhpcyBpcyBub3JtYWwgZm9yIG5ldyB2ZW5kb3JzXCIpO1xuICAgICAgICAgIHNldFByb2ZpbGUobnVsbCk7XG4gICAgICAgICAgc2V0Q29udGFjdHMoW10pO1xuICAgICAgICAgIHNldExvY2F0aW9ucyhbXSk7XG4gICAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIDQwNiBlcnJvciBhbmQgd2UgaGF2ZSByZXRyaWVzIGxlZnQsIHdhaXQgYW5kIHRyeSBhZ2FpblxuICAgICAgICBpZiAocHJvZmlsZUVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCc0MDYnKSAmJiBhdHRlbXB0IDwgbWF4UmV0cmllcykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBSZWNlaXZlZCA0MDYgZXJyb3IsIHJldHJ5aW5nIGluICR7cmV0cnlEZWxheX1tcyAoYXR0ZW1wdCAke2F0dGVtcHR9LyR7bWF4UmV0cmllc30pYCk7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHJldHJ5RGVsYXkpKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlJ3ZlIGV4aGF1c3RlZCByZXRyaWVzIG9yIGl0J3MgYSBkaWZmZXJlbnQgZXJyb3IsIGJyZWFrXG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3VjY2VzcywgYnJlYWsgb3V0IG9mIHJldHJ5IGxvb3BcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2ZpbGVFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZpbmFsIGVycm9yIGZldGNoaW5nIHZlbmRvciBwcm9maWxlOlwiLCBKU09OLnN0cmluZ2lmeShwcm9maWxlRXJyb3IsIG51bGwsIDIpKTtcbiAgICAgIHNldEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgcHJvZmlsZSBkYXRhLiBQbGVhc2UgdHJ5IHJlZnJlc2hpbmcgdGhlIHBhZ2UuXCIpO1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0UHJvZmlsZShwcm9maWxlRGF0YSk7XG5cbiAgICAvLyBGZXRjaCB2ZW5kb3IgY29udGFjdHNcbiAgICBjb25zdCB7IGRhdGE6IGNvbnRhY3RzRGF0YSwgZXJyb3I6IGNvbnRhY3RzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcInZlbmRvcl9jb250YWN0c1wiKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5lcShcInZlbmRvcl9pZFwiLCBwcm9maWxlRGF0YS5pZClcbiAgICAgIC5vcmRlcihcImlzX3ByaW1hcnlcIiwgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xuXG4gICAgaWYgKGNvbnRhY3RzRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyB2ZW5kb3IgY29udGFjdHM6XCIsIGNvbnRhY3RzRXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRDb250YWN0cyhjb250YWN0c0RhdGEgfHwgW10pO1xuICAgIH1cblxuICAgIC8vIEZldGNoIHZlbmRvciBsb2NhdGlvbnNcbiAgICBjb25zdCB7IGRhdGE6IGxvY2F0aW9uc0RhdGEsIGVycm9yOiBsb2NhdGlvbnNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwidmVuZG9yX2xvY2F0aW9uc1wiKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5lcShcInZlbmRvcl9pZFwiLCBwcm9maWxlRGF0YS5pZCk7XG5cbiAgICBpZiAobG9jYXRpb25zRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyB2ZW5kb3IgbG9jYXRpb25zOlwiLCBsb2NhdGlvbnNFcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldExvY2F0aW9ucyhsb2NhdGlvbnNEYXRhIHx8IFtdKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBmZXRjaFByb2ZpbGU6XCIsIGVycik7XG4gICAgc2V0RXJyb3IoXCJBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkXCIpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICB9XG59O1xuXG4gIGNvbnN0IHNhdmVQcm9maWxlID0gYXN5bmMgKGRhdGE6IHtcbiAgICBidXNpbmVzc19uYW1lOiBzdHJpbmc7XG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgICBidXNpbmVzc19jYXRlZ29yeTogc3RyaW5nO1xuICAgIGV2ZW50X3R5cGVzOiBzdHJpbmdbXTtcbiAgICBsb2dvX3VybD86IHN0cmluZyB8IG51bGw7XG4gICAgY29udGFjdHM6IEFycmF5PHtcbiAgICAgIGNvbnRhY3RfdHlwZTogXCJlbWFpbFwiIHwgXCJwaG9uZVwiO1xuICAgICAgY29udGFjdF92YWx1ZTogc3RyaW5nO1xuICAgICAgaXNfcHJpbWFyeTogYm9vbGVhbjtcbiAgICB9PjtcbiAgICBsb2NhdGlvbnM6IHN0cmluZ1tdO1xuICB9KSA9PiB7XG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiTm8gdXNlciBmb3VuZFwiIH07XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50Q29tcG9uZW50Q2xpZW50KCk7XG5cbiAgICAgIGxldCB2ZW5kb3JQcm9maWxlSWQ6IHN0cmluZztcblxuICAgICAgaWYgKCFwcm9maWxlKSB7XG4gICAgICAgIC8vIE5vIHByb2ZpbGUgZXhpc3RzLCBjcmVhdGUgb25lXG4gICAgICAgIGNvbnNvbGUubG9nKFwiTm8gdmVuZG9yIHByb2ZpbGUgZm91bmQsIGNyZWF0aW5nIG5ldyBvbmUuLi5cIik7XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgdW5pcXVlIHNsdWcgZm9yIHRoZSB2ZW5kb3JcbiAgICAgICAgbGV0IHNsdWc6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IGdlbmVyYXRlVW5pcXVlU2x1ZyB9ID0gYXdhaXQgaW1wb3J0KFwiQC9saWIvc2x1Zy11dGlsc1wiKTtcbiAgICAgICAgICBzbHVnID0gYXdhaXQgZ2VuZXJhdGVVbmlxdWVTbHVnKGRhdGEuYnVzaW5lc3NfbmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKHNsdWdFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGdlbmVyYXRlIHNsdWcsIGNyZWF0aW5nIHZlbmRvciB3aXRob3V0IHNsdWc6Jywgc2x1Z0Vycm9yKTtcbiAgICAgICAgICAvLyBDb250aW51ZSB3aXRob3V0IHNsdWcgLSBpdCB3aWxsIHVzZSBJRCBmb3Igcm91dGluZ1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBkYXRhOiBuZXdQcm9maWxlLCBlcnJvcjogY3JlYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oXCJ2ZW5kb3JfcHJvZmlsZXNcIilcbiAgICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgICAgICBidXNpbmVzc19uYW1lOiBkYXRhLmJ1c2luZXNzX25hbWUsXG4gICAgICAgICAgICAuLi4oc2x1ZyAmJiB7IHNsdWcgfSksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZGF0YS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGJ1c2luZXNzX2NhdGVnb3J5OiBkYXRhLmJ1c2luZXNzX2NhdGVnb3J5IGFzIGFueSxcbiAgICAgICAgICAgIGV2ZW50X3R5cGVzOiBkYXRhLmV2ZW50X3R5cGVzIGFzIGFueSxcbiAgICAgICAgICAgIGxvZ29fdXJsOiBkYXRhLmxvZ29fdXJsLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICAgIGlmIChjcmVhdGVFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIHZlbmRvciBwcm9maWxlOlwiLCBjcmVhdGVFcnJvcik7XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkZhaWxlZCB0byBjcmVhdGUgcHJvZmlsZVwiIH07XG4gICAgICAgIH1cblxuICAgICAgICB2ZW5kb3JQcm9maWxlSWQgPSBuZXdQcm9maWxlLmlkO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlZlbmRvciBwcm9maWxlIGNyZWF0ZWQgd2l0aCBJRDpcIiwgdmVuZG9yUHJvZmlsZUlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFByb2ZpbGUgZXhpc3RzLCB1cGRhdGUgaXRcbiAgICAgICAgdmVuZG9yUHJvZmlsZUlkID0gcHJvZmlsZS5pZDtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIlVwZGF0aW5nIGV4aXN0aW5nIHZlbmRvciBwcm9maWxlLi4uXCIpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGJ1c2luZXNzIG5hbWUgY2hhbmdlZCBhbmQgcmVnZW5lcmF0ZSBzbHVnIGlmIG5lZWRlZFxuICAgICAgICBsZXQgdXBkYXRlRGF0YTogYW55ID0ge1xuICAgICAgICAgIGJ1c2luZXNzX25hbWU6IGRhdGEuYnVzaW5lc3NfbmFtZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogZGF0YS5kZXNjcmlwdGlvbixcbiAgICAgICAgICBidXNpbmVzc19jYXRlZ29yeTogZGF0YS5idXNpbmVzc19jYXRlZ29yeSBhcyBhbnksXG4gICAgICAgICAgZXZlbnRfdHlwZXM6IGRhdGEuZXZlbnRfdHlwZXMgYXMgYW55LFxuICAgICAgICAgIGxvZ29fdXJsOiBkYXRhLmxvZ29fdXJsLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocHJvZmlsZS5idXNpbmVzc19uYW1lICE9PSBkYXRhLmJ1c2luZXNzX25hbWUpIHtcbiAgICAgICAgICAvLyBCdXNpbmVzcyBuYW1lIGNoYW5nZWQsIHJlZ2VuZXJhdGUgc2x1Z1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGdlbmVyYXRlVW5pcXVlU2x1ZyB9ID0gYXdhaXQgaW1wb3J0KFwiQC9saWIvc2x1Zy11dGlsc1wiKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NsdWcgPSBhd2FpdCBnZW5lcmF0ZVVuaXF1ZVNsdWcoZGF0YS5idXNpbmVzc19uYW1lLCBwcm9maWxlLnNsdWcgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHVwZGF0ZURhdGEuc2x1ZyA9IG5ld1NsdWc7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgQnVzaW5lc3MgbmFtZSBjaGFuZ2VkLCByZWdlbmVyYXRpbmcgc2x1ZzogJHtuZXdTbHVnfWApO1xuICAgICAgICAgIH0gY2F0Y2ggKHNsdWdFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcmVnZW5lcmF0ZSBzbHVnLCBrZWVwaW5nIGV4aXN0aW5nIHNsdWc6Jywgc2x1Z0Vycm9yKTtcbiAgICAgICAgICAgIC8vIEtlZXAgZXhpc3Rpbmcgc2x1ZyBvciBkb24ndCB1cGRhdGUgaXRcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGRhdGE6IHVwZGF0ZVJlc3VsdCwgZXJyb3I6IHByb2ZpbGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbShcInZlbmRvcl9wcm9maWxlc1wiKVxuICAgICAgICAgIC51cGRhdGUodXBkYXRlRGF0YSlcbiAgICAgICAgICAuZXEoXCJpZFwiLCBwcm9maWxlLmlkKVxuICAgICAgICAgIC5zZWxlY3QoKTtcblxuICAgICAgICBpZiAocHJvZmlsZUVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkZhaWxlZCB0byB1cGRhdGUgcHJvZmlsZVwiIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coXCLwn5eR77iPIERlbGV0aW5nIGV4aXN0aW5nIGNvbnRhY3RzIGFuZCBsb2NhdGlvbnMuLi5cIik7XG4gICAgICBcbiAgICAgIC8vIERlbGV0ZSBjb250YWN0cyBmaXJzdCAob25seSBpZiBwcm9maWxlIGV4aXN0ZWQgYmVmb3JlKVxuICAgICAgaWYgKHByb2ZpbGUpIHtcbiAgICAgICAgY29uc3QgeyBlcnJvcjogZGVsZXRlQ29udGFjdHNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbShcInZlbmRvcl9jb250YWN0c1wiKVxuICAgICAgICAgIC5kZWxldGUoKVxuICAgICAgICAgIC5lcShcInZlbmRvcl9pZFwiLCBwcm9maWxlLmlkKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk54gQ29udGFjdHMgZGVsZXRlIGVycm9yOlwiLCBkZWxldGVDb250YWN0c0Vycm9yKTtcblxuICAgICAgICBpZiAoZGVsZXRlQ29udGFjdHNFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwi4p2MIEZhaWxlZCB0byBkZWxldGUgY29udGFjdHM6XCIsIGRlbGV0ZUNvbnRhY3RzRXJyb3IpO1xuICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJGYWlsZWQgdG8gZGVsZXRlIGV4aXN0aW5nIGNvbnRhY3RzXCIgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwi4pyFIENvbnRhY3RzIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgICBcbiAgICAgICAgLy8gRGVsZXRlIGxvY2F0aW9uc1xuICAgICAgICBjb25zdCB7IGVycm9yOiBkZWxldGVMb2NhdGlvbnNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbShcInZlbmRvcl9sb2NhdGlvbnNcIilcbiAgICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgICAuZXEoXCJ2ZW5kb3JfaWRcIiwgcHJvZmlsZS5pZCk7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCLwn5ONIExvY2F0aW9ucyBkZWxldGUgZXJyb3I6XCIsIGRlbGV0ZUxvY2F0aW9uc0Vycm9yKTtcblxuICAgICAgICBpZiAoZGVsZXRlTG9jYXRpb25zRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIuKdjCBGYWlsZWQgdG8gZGVsZXRlIGxvY2F0aW9uczpcIiwgZGVsZXRlTG9jYXRpb25zRXJyb3IpO1xuICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJGYWlsZWQgdG8gZGVsZXRlIGV4aXN0aW5nIGxvY2F0aW9uc1wiIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBMb2NhdGlvbnMgZGVsZXRlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKFwi8J+TniBJbnNlcnRpbmcgbmV3IGNvbnRhY3RzLi4uXCIpO1xuICAgICAgXG4gICAgICAvLyBJbnNlcnQgbmV3IGNvbnRhY3RzXG4gICAgICBpZiAoZGF0YS5jb250YWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+TiyBDb250YWN0cyB0byBpbnNlcnQ6XCIsIGRhdGEuY29udGFjdHMpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgeyBlcnJvcjogY29udGFjdHNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbShcInZlbmRvcl9jb250YWN0c1wiKVxuICAgICAgICAgIC5pbnNlcnQoXG4gICAgICAgICAgICBkYXRhLmNvbnRhY3RzLm1hcCgoY29udGFjdCkgPT4gKHtcbiAgICAgICAgICAgICAgdmVuZG9yX2lkOiB2ZW5kb3JQcm9maWxlSWQsXG4gICAgICAgICAgICAgIGNvbnRhY3RfdHlwZTogY29udGFjdC5jb250YWN0X3R5cGUsXG4gICAgICAgICAgICAgIGNvbnRhY3RfdmFsdWU6IGNvbnRhY3QuY29udGFjdF92YWx1ZSxcbiAgICAgICAgICAgICAgaXNfcHJpbWFyeTogY29udGFjdC5pc19wcmltYXJ5LFxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk54gQ29udGFjdHMgaW5zZXJ0IGVycm9yOlwiLCBjb250YWN0c0Vycm9yKTtcblxuICAgICAgICBpZiAoY29udGFjdHNFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwi4p2MIEZhaWxlZCB0byBpbnNlcnQgY29udGFjdHM6XCIsIGNvbnRhY3RzRXJyb3IpO1xuICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJGYWlsZWQgdG8gdXBkYXRlIGNvbnRhY3RzXCIgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwi4pyFIENvbnRhY3RzIGluc2VydGVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwi4oS577iPIE5vIGNvbnRhY3RzIHRvIGluc2VydFwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coXCLwn5ONIEluc2VydGluZyBuZXcgbG9jYXRpb25zLi4uXCIpO1xuICAgICAgXG4gICAgICAvLyBJbnNlcnQgbmV3IGxvY2F0aW9uc1xuICAgICAgaWYgKGRhdGEubG9jYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5e677iPIExvY2F0aW9ucyB0byBpbnNlcnQ6XCIsIGRhdGEubG9jYXRpb25zKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFZhbGlkYXRlIGxvY2F0aW9uIHZhbHVlc1xuICAgICAgICBjb25zdCB2YWxpZExvY2F0aW9ucyA9IFtcbiAgICAgICAgICBcIm5pY29zaWFcIiwgXCJsaW1hc3NvbFwiLCBcImxhcm5hY2FcIiwgXCJwYXBob3NcIiwgXG4gICAgICAgICAgXCJwbGF0cmVzXCIsIFwicGFyYWxpbW5pX2F5aWFfbmFwYVwiLCBcIndob2xlX2N5cHJ1c1wiXG4gICAgICAgIF07XG4gICAgICAgIFxuICAgICAgICBjb25zdCBpbnZhbGlkTG9jYXRpb25zID0gZGF0YS5sb2NhdGlvbnMuZmlsdGVyKFxuICAgICAgICAgIGxvY2F0aW9uID0+ICF2YWxpZExvY2F0aW9ucy5pbmNsdWRlcyhsb2NhdGlvbilcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChpbnZhbGlkTG9jYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIuKdjCBJbnZhbGlkIGxvY2F0aW9uIHZhbHVlczpcIiwgaW52YWxpZExvY2F0aW9ucyk7XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBgSW52YWxpZCBsb2NhdGlvbiB2YWx1ZXM6ICR7aW52YWxpZExvY2F0aW9ucy5qb2luKFwiLCBcIil9YCB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBsb2NhdGlvbkRhdGEgPSBkYXRhLmxvY2F0aW9ucy5tYXAoKGxvY2F0aW9uKSA9PiAoe1xuICAgICAgICAgIHZlbmRvcl9pZDogdmVuZG9yUHJvZmlsZUlkLFxuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgfSkpO1xuICBcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5e677iPIExvY2F0aW9uIGRhdGEgdG8gaW5zZXJ0OlwiLCBsb2NhdGlvbkRhdGEpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgeyBkYXRhOiBpbnNlcnRlZExvY2F0aW9ucywgZXJyb3I6IGxvY2F0aW9uc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKFwidmVuZG9yX2xvY2F0aW9uc1wiKVxuICAgICAgICAgIC5pbnNlcnQobG9jYXRpb25EYXRhKVxuICAgICAgICAgIC5zZWxlY3QoKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk40gTG9jYXRpb25zIGluc2VydCBlcnJvcjpcIiwgbG9jYXRpb25zRXJyb3IpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk40gSW5zZXJ0ZWQgbG9jYXRpb25zOlwiLCBpbnNlcnRlZExvY2F0aW9ucyk7XG5cbiAgICAgICAgaWYgKGxvY2F0aW9uc0Vycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCLinYwgRmFpbGVkIHRvIGluc2VydCBsb2NhdGlvbnM6XCIsIGxvY2F0aW9uc0Vycm9yKTtcbiAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiRmFpbGVkIHRvIHVwZGF0ZSBsb2NhdGlvbnNcIiB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBMb2NhdGlvbnMgaW5zZXJ0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCLihLnvuI8gTm8gbG9jYXRpb25zIHRvIGluc2VydFwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coXCLwn5SEIFJlZmV0Y2hpbmcgcHJvZmlsZSBkYXRhLi4uXCIpO1xuICAgICAgXG4gICAgICAvLyBSZWZldGNoIGRhdGEgdG8gdXBkYXRlIHRoZSBVSVxuICAgICAgYXdhaXQgZmV0Y2hQcm9maWxlKCk7XG5cbiAgICAgIGNvbnNvbGUubG9nKFwi8J+OiSBQcm9maWxlIHNhdmUgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSFcIik7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIvCfkqUgRXhjZXB0aW9uIGluIHNhdmVQcm9maWxlOlwiLCBlcnIpO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWRcIiB9O1xuICAgIH1cbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGZldGNoUHJvZmlsZSgpO1xuICB9LCBbdXNlcl0pO1xuXG4gIHJldHVybiB7XG4gICAgcHJvZmlsZSxcbiAgICBjb250YWN0cyxcbiAgICBsb2NhdGlvbnMsXG4gICAgbG9hZGluZyxcbiAgICBlcnJvcixcbiAgICByZWZldGNoOiBmZXRjaFByb2ZpbGUsXG4gICAgc2F2ZVByb2ZpbGUsXG4gIH07XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VBdXRoIiwiY3JlYXRlQ2xpZW50Q29tcG9uZW50Q2xpZW50IiwidXNlVmVuZG9yUHJvZmlsZSIsInVzZXIiLCJwcm9maWxlIiwic2V0UHJvZmlsZSIsImNvbnRhY3RzIiwic2V0Q29udGFjdHMiLCJsb2NhdGlvbnMiLCJzZXRMb2NhdGlvbnMiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJmZXRjaFByb2ZpbGUiLCJzdXBhYmFzZSIsImRhdGEiLCJ1c2VyUHJvZmlsZSIsInVzZXJQcm9maWxlRXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJpZCIsInNpbmdsZSIsImNvbnNvbGUiLCJ1c2VyX3R5cGUiLCJsb2ciLCJwcm9maWxlRGF0YSIsInZlbmRvclByb2ZpbGVFcnJvciIsIm1heFJldHJpZXMiLCJyZXRyeURlbGF5IiwiYXR0ZW1wdCIsInByb2ZpbGVFcnJvciIsImNvZGUiLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJKU09OIiwic3RyaW5naWZ5IiwiY29udGFjdHNEYXRhIiwiY29udGFjdHNFcnJvciIsIm9yZGVyIiwiYXNjZW5kaW5nIiwibG9jYXRpb25zRGF0YSIsImxvY2F0aW9uc0Vycm9yIiwiZXJyIiwic2F2ZVByb2ZpbGUiLCJzdWNjZXNzIiwidmVuZG9yUHJvZmlsZUlkIiwic2x1ZyIsImdlbmVyYXRlVW5pcXVlU2x1ZyIsImJ1c2luZXNzX25hbWUiLCJzbHVnRXJyb3IiLCJ3YXJuIiwibmV3UHJvZmlsZSIsImNyZWF0ZUVycm9yIiwiaW5zZXJ0IiwidXNlcl9pZCIsImRlc2NyaXB0aW9uIiwiYnVzaW5lc3NfY2F0ZWdvcnkiLCJldmVudF90eXBlcyIsImxvZ29fdXJsIiwidXBkYXRlRGF0YSIsInVwZGF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJuZXdTbHVnIiwidW5kZWZpbmVkIiwidXBkYXRlUmVzdWx0IiwidXBkYXRlIiwiZGVsZXRlQ29udGFjdHNFcnJvciIsImRlbGV0ZSIsImRlbGV0ZUxvY2F0aW9uc0Vycm9yIiwibGVuZ3RoIiwibWFwIiwiY29udGFjdCIsInZlbmRvcl9pZCIsImNvbnRhY3RfdHlwZSIsImNvbnRhY3RfdmFsdWUiLCJpc19wcmltYXJ5IiwidmFsaWRMb2NhdGlvbnMiLCJpbnZhbGlkTG9jYXRpb25zIiwiZmlsdGVyIiwibG9jYXRpb24iLCJqb2luIiwibG9jYXRpb25EYXRhIiwiaW5zZXJ0ZWRMb2NhdGlvbnMiLCJyZWZldGNoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useVendorProfile.ts\n"));

/***/ })

});