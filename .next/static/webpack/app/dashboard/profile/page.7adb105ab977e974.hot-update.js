"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/profile/page",{

/***/ "(app-pages-browser)/./src/hooks/useVendorProfile.ts":
/*!***************************************!*\
  !*** ./src/hooks/useVendorProfile.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useVendorProfile: () => (/* binding */ useVendorProfile)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _contexts_AuthContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/contexts/AuthContext */ \"(app-pages-browser)/./src/contexts/AuthContext.tsx\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n\n\n\nfunction useVendorProfile() {\n    const { user } = (0,_contexts_AuthContext__WEBPACK_IMPORTED_MODULE_1__.useAuth)();\n    const [profile, setProfile] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [contacts, setContacts] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [locations, setLocations] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchProfile = async ()=>{\n        if (!user) {\n            setLoading(false);\n            return;\n        }\n        try {\n            // First check if user is a vendor by querying their profile\n            const supabase = (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.createClientComponentClient)();\n            const { data: userProfile, error: userProfileError } = await supabase.from(\"profiles\").select(\"user_type\").eq(\"id\", user.id).single();\n            if (userProfileError) {\n                console.error(\"Error fetching user profile:\", userProfileError);\n                setError(\"Failed to verify user type\");\n                setLoading(false);\n                return;\n            }\n            // Only proceed if user is a vendor\n            if (userProfile.user_type !== \"vendor\") {\n                console.log(\"User is not a vendor, skipping vendor profile fetch\");\n                setProfile(null);\n                setContacts([]);\n                setLocations([]);\n                setLoading(false);\n                return;\n            }\n            // Now fetch vendor profile with retry logic for timing issues\n            let profileData = null;\n            let vendorProfileError = null;\n            const maxRetries = 3;\n            const retryDelay = 1000;\n            for(let attempt = 1; attempt <= maxRetries; attempt++){\n                const { data, error } = await supabase.from(\"vendor_profiles\").select(\"*\").eq(\"user_id\", user.id).single();\n                profileData = data;\n                vendorProfileError = error;\n                if (profileError) {\n                    var _profileError_message;\n                    console.error(\"Error fetching vendor profile (attempt \".concat(attempt, \"/\").concat(maxRetries, \"):\"), profileError);\n                    // If vendor profile doesn't exist, that's expected for new vendors\n                    if (profileError.code === 'PGRST116') {\n                        console.log(\"Vendor profile doesn't exist yet - this is normal for new vendors\");\n                        setProfile(null);\n                        setContacts([]);\n                        setLocations([]);\n                        setError(null);\n                        setLoading(false);\n                        return;\n                    }\n                    // If this is a 406 error and we have retries left, wait and try again\n                    if (((_profileError_message = profileError.message) === null || _profileError_message === void 0 ? void 0 : _profileError_message.includes('406')) && attempt < maxRetries) {\n                        console.log(\"Received 406 error, retrying in \".concat(retryDelay, \"ms (attempt \").concat(attempt, \"/\").concat(maxRetries, \")\"));\n                        await new Promise((resolve)=>setTimeout(resolve, retryDelay));\n                        continue;\n                    }\n                    break;\n                } else {\n                    break;\n                }\n            }\n            if (profileError) {\n                console.error(\"Final error fetching vendor profile:\", JSON.stringify(profileError, null, 2));\n                setError(\"Failed to load profile data. Please try refreshing the page.\");\n                setLoading(false);\n                return;\n            }\n            setProfile(profileData);\n            // Fetch vendor contacts\n            const { data: contactsData, error: contactsError } = await supabase.from(\"vendor_contacts\").select(\"*\").eq(\"vendor_id\", profileData.id).order(\"is_primary\", {\n                ascending: false\n            });\n            if (contactsError) {\n                console.error(\"Error fetching vendor contacts:\", contactsError);\n            } else {\n                setContacts(contactsData || []);\n            }\n            // Fetch vendor locations\n            const { data: locationsData, error: locationsError } = await supabase.from(\"vendor_locations\").select(\"*\").eq(\"vendor_id\", profileData.id);\n            if (locationsError) {\n                console.error(\"Error fetching vendor locations:\", locationsError);\n            } else {\n                setLocations(locationsData || []);\n            }\n        } catch (err) {\n            console.error(\"Error in fetchProfile:\", err);\n            setError(\"An unexpected error occurred\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    const saveProfile = async (data)=>{\n        if (!user) {\n            return {\n                success: false,\n                error: \"No user found\"\n            };\n        }\n        try {\n            const supabase = (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.createClientComponentClient)();\n            let vendorProfileId;\n            if (!profile) {\n                // No profile exists, create one\n                console.log(\"No vendor profile found, creating new one...\");\n                // Generate unique slug for the vendor\n                let slug;\n                try {\n                    const { generateUniqueSlug } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_lib_slug-utils_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/slug-utils */ \"(app-pages-browser)/./src/lib/slug-utils.ts\"));\n                    slug = await generateUniqueSlug(data.business_name);\n                } catch (slugError) {\n                    console.warn('Failed to generate slug, creating vendor without slug:', slugError);\n                // Continue without slug - it will use ID for routing\n                }\n                const { data: newProfile, error: createError } = await supabase.from(\"vendor_profiles\").insert({\n                    user_id: user.id,\n                    business_name: data.business_name,\n                    ...slug && {\n                        slug\n                    },\n                    description: data.description,\n                    business_category: data.business_category,\n                    event_types: data.event_types,\n                    logo_url: data.logo_url\n                }).select().single();\n                if (createError) {\n                    console.error(\"Failed to create vendor profile:\", createError);\n                    return {\n                        success: false,\n                        error: \"Failed to create profile\"\n                    };\n                }\n                vendorProfileId = newProfile.id;\n                console.log(\"Vendor profile created with ID:\", vendorProfileId);\n            } else {\n                // Profile exists, update it\n                vendorProfileId = profile.id;\n                console.log(\"Updating existing vendor profile...\");\n                // Check if business name changed and regenerate slug if needed\n                let updateData = {\n                    business_name: data.business_name,\n                    description: data.description,\n                    business_category: data.business_category,\n                    event_types: data.event_types,\n                    logo_url: data.logo_url,\n                    updated_at: new Date().toISOString()\n                };\n                if (profile.business_name !== data.business_name) {\n                    // Business name changed, regenerate slug\n                    try {\n                        const { generateUniqueSlug } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_lib_slug-utils_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/slug-utils */ \"(app-pages-browser)/./src/lib/slug-utils.ts\"));\n                        const newSlug = await generateUniqueSlug(data.business_name, profile.slug || undefined);\n                        updateData.slug = newSlug;\n                        console.log(\"Business name changed, regenerating slug: \".concat(newSlug));\n                    } catch (slugError) {\n                        console.warn('Failed to regenerate slug, keeping existing slug:', slugError);\n                    // Keep existing slug or don't update it\n                    }\n                }\n                const { data: updateResult, error: profileError1 } = await supabase.from(\"vendor_profiles\").update(updateData).eq(\"id\", profile.id).select();\n                if (profileError1) {\n                    return {\n                        success: false,\n                        error: \"Failed to update profile\"\n                    };\n                }\n            }\n            console.log(\"🗑️ Deleting existing contacts and locations...\");\n            // Delete contacts first (only if profile existed before)\n            if (profile) {\n                const { error: deleteContactsError } = await supabase.from(\"vendor_contacts\").delete().eq(\"vendor_id\", profile.id);\n                console.log(\"📞 Contacts delete error:\", deleteContactsError);\n                if (deleteContactsError) {\n                    console.log(\"❌ Failed to delete contacts:\", deleteContactsError);\n                    return {\n                        success: false,\n                        error: \"Failed to delete existing contacts\"\n                    };\n                }\n                console.log(\"✅ Contacts deleted successfully\");\n                // Delete locations\n                const { error: deleteLocationsError } = await supabase.from(\"vendor_locations\").delete().eq(\"vendor_id\", profile.id);\n                console.log(\"📍 Locations delete error:\", deleteLocationsError);\n                if (deleteLocationsError) {\n                    console.log(\"❌ Failed to delete locations:\", deleteLocationsError);\n                    return {\n                        success: false,\n                        error: \"Failed to delete existing locations\"\n                    };\n                }\n                console.log(\"✅ Locations deleted successfully\");\n            }\n            console.log(\"📞 Inserting new contacts...\");\n            // Insert new contacts\n            if (data.contacts.length > 0) {\n                console.log(\"📋 Contacts to insert:\", data.contacts);\n                const { error: contactsError } = await supabase.from(\"vendor_contacts\").insert(data.contacts.map((contact)=>({\n                        vendor_id: vendorProfileId,\n                        contact_type: contact.contact_type,\n                        contact_value: contact.contact_value,\n                        is_primary: contact.is_primary\n                    })));\n                console.log(\"📞 Contacts insert error:\", contactsError);\n                if (contactsError) {\n                    console.log(\"❌ Failed to insert contacts:\", contactsError);\n                    return {\n                        success: false,\n                        error: \"Failed to update contacts\"\n                    };\n                }\n                console.log(\"✅ Contacts inserted successfully\");\n            } else {\n                console.log(\"ℹ️ No contacts to insert\");\n            }\n            console.log(\"📍 Inserting new locations...\");\n            // Insert new locations\n            if (data.locations.length > 0) {\n                console.log(\"🗺️ Locations to insert:\", data.locations);\n                // Validate location values\n                const validLocations = [\n                    \"nicosia\",\n                    \"limassol\",\n                    \"larnaca\",\n                    \"paphos\",\n                    \"platres\",\n                    \"paralimni_ayia_napa\",\n                    \"whole_cyprus\"\n                ];\n                const invalidLocations = data.locations.filter((location)=>!validLocations.includes(location));\n                if (invalidLocations.length > 0) {\n                    console.log(\"❌ Invalid location values:\", invalidLocations);\n                    return {\n                        success: false,\n                        error: \"Invalid location values: \".concat(invalidLocations.join(\", \"))\n                    };\n                }\n                const locationData = data.locations.map((location)=>({\n                        vendor_id: vendorProfileId,\n                        location: location\n                    }));\n                console.log(\"🗺️ Location data to insert:\", locationData);\n                const { data: insertedLocations, error: locationsError } = await supabase.from(\"vendor_locations\").insert(locationData).select();\n                console.log(\"📍 Locations insert error:\", locationsError);\n                console.log(\"📍 Inserted locations:\", insertedLocations);\n                if (locationsError) {\n                    console.log(\"❌ Failed to insert locations:\", locationsError);\n                    return {\n                        success: false,\n                        error: \"Failed to update locations\"\n                    };\n                }\n                console.log(\"✅ Locations inserted successfully\");\n            } else {\n                console.log(\"ℹ️ No locations to insert\");\n            }\n            console.log(\"🔄 Refetching profile data...\");\n            // Refetch data to update the UI\n            await fetchProfile();\n            console.log(\"🎉 Profile save completed successfully!\");\n            return {\n                success: true\n            };\n        } catch (err) {\n            console.log(\"💥 Exception in saveProfile:\", err);\n            return {\n                success: false,\n                error: \"An unexpected error occurred\"\n            };\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useVendorProfile.useEffect\": ()=>{\n            fetchProfile();\n        }\n    }[\"useVendorProfile.useEffect\"], [\n        user\n    ]);\n    return {\n        profile,\n        contacts,\n        locations,\n        loading,\n        error,\n        refetch: fetchProfile,\n        saveProfile\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VWZW5kb3JQcm9maWxlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTRDO0FBQ0s7QUFDc0I7QUFxRGhFLFNBQVNJO0lBQ2QsTUFBTSxFQUFFQyxJQUFJLEVBQUUsR0FBR0gsOERBQU9BO0lBQ3hCLE1BQU0sQ0FBQ0ksU0FBU0MsV0FBVyxHQUFHUCwrQ0FBUUEsQ0FBdUI7SUFDN0QsTUFBTSxDQUFDUSxVQUFVQyxZQUFZLEdBQUdULCtDQUFRQSxDQUFrQixFQUFFO0lBQzVELE1BQU0sQ0FBQ1UsV0FBV0MsYUFBYSxHQUFHWCwrQ0FBUUEsQ0FBbUIsRUFBRTtJQUMvRCxNQUFNLENBQUNZLFNBQVNDLFdBQVcsR0FBR2IsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDYyxPQUFPQyxTQUFTLEdBQUdmLCtDQUFRQSxDQUFnQjtJQUVsRCxNQUFNZ0IsZUFBZTtRQUNuQixJQUFJLENBQUNYLE1BQU07WUFDVFEsV0FBVztZQUNYO1FBQ0Y7UUFFQSxJQUFJO1lBQ0YsNERBQTREO1lBQzVELE1BQU1JLFdBQVdkLDBFQUEyQkE7WUFDNUMsTUFBTSxFQUFFZSxNQUFNQyxXQUFXLEVBQUVMLE9BQU9NLGdCQUFnQixFQUFFLEdBQUcsTUFBTUgsU0FDMURJLElBQUksQ0FBQyxZQUNMQyxNQUFNLENBQUMsYUFDUEMsRUFBRSxDQUFDLE1BQU1sQixLQUFLbUIsRUFBRSxFQUNoQkMsTUFBTTtZQUVULElBQUlMLGtCQUFrQjtnQkFDcEJNLFFBQVFaLEtBQUssQ0FBQyxnQ0FBZ0NNO2dCQUM5Q0wsU0FBUztnQkFDVEYsV0FBVztnQkFDWDtZQUNGO1lBRUEsbUNBQW1DO1lBQ25DLElBQUlNLFlBQVlRLFNBQVMsS0FBSyxVQUFVO2dCQUN0Q0QsUUFBUUUsR0FBRyxDQUFDO2dCQUNackIsV0FBVztnQkFDWEUsWUFBWSxFQUFFO2dCQUNkRSxhQUFhLEVBQUU7Z0JBQ2ZFLFdBQVc7Z0JBQ1g7WUFDRjtZQUVBLDhEQUE4RDtZQUNo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QUM7WUFFWixnQ0FBZ0M7WUFDaEMsTUFBTVo7WUFFTlUsUUFBUUUsR0FBRyxDQUFDO1lBQ1osT0FBTztnQkFBRXVCLFNBQVM7WUFBSztRQUN6QixFQUFFLE9BQU9GLEtBQUs7WUFDWnZCLFFBQVFFLEdBQUcsQ0FBQyxnQ0FBZ0NxQjtZQUM1QyxPQUFPO2dCQUFFRSxTQUFTO2dCQUFPckMsT0FBTztZQUErQjtRQUNqRTtJQUNGO0lBRUFiLGdEQUFTQTtzQ0FBQztZQUNSZTtRQUNGO3FDQUFHO1FBQUNYO0tBQUs7SUFFVCxPQUFPO1FBQ0xDO1FBQ0FFO1FBQ0FFO1FBQ0FFO1FBQ0FFO1FBQ0E2RSxTQUFTM0U7UUFDVGtDO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2RhdmlkYmFsaWFuL0Rlc2t0b3AvbW9tZW50bW9pLXZvaWQvc3JjL2hvb2tzL3VzZVZlbmRvclByb2ZpbGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlQXV0aCB9IGZyb20gXCJAL2NvbnRleHRzL0F1dGhDb250ZXh0XCI7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnRDb21wb25lbnRDbGllbnQsIHN1cGFiYXNlIH0gZnJvbSBcIkAvbGliL3N1cGFiYXNlXCI7XG5cbmludGVyZmFjZSBWZW5kb3JQcm9maWxlIHtcbiAgaWQ6IHN0cmluZztcbiAgdXNlcl9pZDogc3RyaW5nO1xuICBzbHVnOiBzdHJpbmcgfCBudWxsO1xuICBidXNpbmVzc19uYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmcgfCBudWxsO1xuICBsb2dvX3VybDogc3RyaW5nIHwgbnVsbDtcbiAgdmVyaWZpZWQ6IGJvb2xlYW47XG4gIGJ1c2luZXNzX2NhdGVnb3J5OiBzdHJpbmc7XG4gIGV2ZW50X3R5cGVzOiBzdHJpbmdbXTtcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICB1cGRhdGVkX2F0OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBWZW5kb3JDb250YWN0IHtcbiAgaWQ6IHN0cmluZztcbiAgdmVuZG9yX2lkOiBzdHJpbmc7XG4gIGNvbnRhY3RfdHlwZTogXCJlbWFpbFwiIHwgXCJwaG9uZVwiO1xuICBjb250YWN0X3ZhbHVlOiBzdHJpbmc7XG4gIGlzX3ByaW1hcnk6IGJvb2xlYW47XG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFZlbmRvckxvY2F0aW9uIHtcbiAgaWQ6IHN0cmluZztcbiAgdmVuZG9yX2lkOiBzdHJpbmc7XG4gIGxvY2F0aW9uOiBzdHJpbmc7XG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFVzZVZlbmRvclByb2ZpbGVSZXR1cm4ge1xuICBwcm9maWxlOiBWZW5kb3JQcm9maWxlIHwgbnVsbDtcbiAgY29udGFjdHM6IFZlbmRvckNvbnRhY3RbXTtcbiAgbG9jYXRpb25zOiBWZW5kb3JMb2NhdGlvbltdO1xuICBsb2FkaW5nOiBib29sZWFuO1xuICBlcnJvcjogc3RyaW5nIHwgbnVsbDtcbiAgcmVmZXRjaDogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgc2F2ZVByb2ZpbGU6IChkYXRhOiB7XG4gICAgYnVzaW5lc3NfbmFtZTogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgYnVzaW5lc3NfY2F0ZWdvcnk6IHN0cmluZztcbiAgICBldmVudF90eXBlczogc3RyaW5nW107XG4gICAgY29udGFjdHM6IEFycmF5PHtcbiAgICAgIGNvbnRhY3RfdHlwZTogXCJlbWFpbFwiIHwgXCJwaG9uZVwiO1xuICAgICAgY29udGFjdF92YWx1ZTogc3RyaW5nO1xuICAgICAgaXNfcHJpbWFyeTogYm9vbGVhbjtcbiAgICB9PjtcbiAgICBsb2NhdGlvbnM6IHN0cmluZ1tdO1xuICB9KSA9PiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfT47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VWZW5kb3JQcm9maWxlKCk6IFVzZVZlbmRvclByb2ZpbGVSZXR1cm4ge1xuICBjb25zdCB7IHVzZXIgfSA9IHVzZUF1dGgoKTtcbiAgY29uc3QgW3Byb2ZpbGUsIHNldFByb2ZpbGVdID0gdXNlU3RhdGU8VmVuZG9yUHJvZmlsZSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbY29udGFjdHMsIHNldENvbnRhY3RzXSA9IHVzZVN0YXRlPFZlbmRvckNvbnRhY3RbXT4oW10pO1xuICBjb25zdCBbbG9jYXRpb25zLCBzZXRMb2NhdGlvbnNdID0gdXNlU3RhdGU8VmVuZG9yTG9jYXRpb25bXT4oW10pO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBmZXRjaFByb2ZpbGUgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdXNlciBpcyBhIHZlbmRvciBieSBxdWVyeWluZyB0aGVpciBwcm9maWxlXG4gICAgICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudENvbXBvbmVudENsaWVudCgpO1xuICAgICAgY29uc3QgeyBkYXRhOiB1c2VyUHJvZmlsZSwgZXJyb3I6IHVzZXJQcm9maWxlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKFwicHJvZmlsZXNcIilcbiAgICAgICAgLnNlbGVjdChcInVzZXJfdHlwZVwiKVxuICAgICAgICAuZXEoXCJpZFwiLCB1c2VyLmlkKVxuICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgIGlmICh1c2VyUHJvZmlsZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyB1c2VyIHByb2ZpbGU6XCIsIHVzZXJQcm9maWxlRXJyb3IpO1xuICAgICAgICBzZXRFcnJvcihcIkZhaWxlZCB0byB2ZXJpZnkgdXNlciB0eXBlXCIpO1xuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBPbmx5IHByb2NlZWQgaWYgdXNlciBpcyBhIHZlbmRvclxuICAgICAgaWYgKHVzZXJQcm9maWxlLnVzZXJfdHlwZSAhPT0gXCJ2ZW5kb3JcIikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVzZXIgaXMgbm90IGEgdmVuZG9yLCBza2lwcGluZyB2ZW5kb3IgcHJvZmlsZSBmZXRjaFwiKTtcbiAgICAgICAgc2V0UHJvZmlsZShudWxsKTtcbiAgICAgICAgc2V0Q29udGFjdHMoW10pO1xuICAgICAgICBzZXRMb2NhdGlvbnMoW10pO1xuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3cgZmV0Y2ggdmVuZG9yIHByb2ZpbGUgd2l0aCByZXRyeSBsb2dpYyBmb3IgdGltaW5nIGlzc3Vlc1xuICAgIGxldCBwcm9maWxlRGF0YSA9IG51bGw7XG4gICAgbGV0IHZlbmRvclByb2ZpbGVFcnJvcjogYW55ID0gbnVsbDtcbiAgICBjb25zdCBtYXhSZXRyaWVzID0gMztcbiAgICBjb25zdCByZXRyeURlbGF5ID0gMTAwMDtcblxuICAgIGZvciAobGV0IGF0dGVtcHQgPSAxOyBhdHRlbXB0IDw9IG1heFJldHJpZXM7IGF0dGVtcHQrKykge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oXCJ2ZW5kb3JfcHJvZmlsZXNcIilcbiAgICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgICAgLmVxKFwidXNlcl9pZFwiLCB1c2VyLmlkKVxuICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgIHByb2ZpbGVEYXRhID0gZGF0YTtcbiAgICAgIHZlbmRvclByb2ZpbGVFcnJvciA9IGVycm9yO1xuXG4gICAgICBpZiAocHJvZmlsZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHZlbmRvciBwcm9maWxlIChhdHRlbXB0ICR7YXR0ZW1wdH0vJHttYXhSZXRyaWVzfSk6YCwgcHJvZmlsZUVycm9yKTtcblxuICAgICAgICAvLyBJZiB2ZW5kb3IgcHJvZmlsZSBkb2Vzbid0IGV4aXN0LCB0aGF0J3MgZXhwZWN0ZWQgZm9yIG5ldyB2ZW5kb3JzXG4gICAgICAgIGlmIChwcm9maWxlRXJyb3IuY29kZSA9PT0gJ1BHUlNUMTE2Jykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiVmVuZG9yIHByb2ZpbGUgZG9lc24ndCBleGlzdCB5ZXQgLSB0aGlzIGlzIG5vcm1hbCBmb3IgbmV3IHZlbmRvcnNcIik7XG4gICAgICAgICAgc2V0UHJvZmlsZShudWxsKTtcbiAgICAgICAgICBzZXRDb250YWN0cyhbXSk7XG4gICAgICAgICAgc2V0TG9jYXRpb25zKFtdKTtcbiAgICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgNDA2IGVycm9yIGFuZCB3ZSBoYXZlIHJldHJpZXMgbGVmdCwgd2FpdCBhbmQgdHJ5IGFnYWluXG4gICAgICAgIGlmIChwcm9maWxlRXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJzQwNicpICYmIGF0dGVtcHQgPCBtYXhSZXRyaWVzKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFJlY2VpdmVkIDQwNiBlcnJvciwgcmV0cnlpbmcgaW4gJHtyZXRyeURlbGF5fW1zIChhdHRlbXB0ICR7YXR0ZW1wdH0vJHttYXhSZXRyaWVzfSlgKTtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheSkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UndmUgZXhoYXVzdGVkIHJldHJpZXMgb3IgaXQncyBhIGRpZmZlcmVudCBlcnJvciwgYnJlYWtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdWNjZXNzLCBicmVhayBvdXQgb2YgcmV0cnkgbG9vcFxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvZmlsZUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmluYWwgZXJyb3IgZmV0Y2hpbmcgdmVuZG9yIHByb2ZpbGU6XCIsIEpTT04uc3RyaW5naWZ5KHByb2ZpbGVFcnJvciwgbnVsbCwgMikpO1xuICAgICAgc2V0RXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBwcm9maWxlIGRhdGEuIFBsZWFzZSB0cnkgcmVmcmVzaGluZyB0aGUgcGFnZS5cIik7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRQcm9maWxlKHByb2ZpbGVEYXRhKTtcblxuICAgIC8vIEZldGNoIHZlbmRvciBjb250YWN0c1xuICAgIGNvbnN0IHsgZGF0YTogY29udGFjdHNEYXRhLCBlcnJvcjogY29udGFjdHNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwidmVuZG9yX2NvbnRhY3RzXCIpXG4gICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgLmVxKFwidmVuZG9yX2lkXCIsIHByb2ZpbGVEYXRhLmlkKVxuICAgICAgLm9yZGVyKFwiaXNfcHJpbWFyeVwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG5cbiAgICBpZiAoY29udGFjdHNFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHZlbmRvciBjb250YWN0czpcIiwgY29udGFjdHNFcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldENvbnRhY3RzKGNvbnRhY3RzRGF0YSB8fCBbXSk7XG4gICAgfVxuXG4gICAgLy8gRmV0Y2ggdmVuZG9yIGxvY2F0aW9uc1xuICAgIGNvbnN0IHsgZGF0YTogbG9jYXRpb25zRGF0YSwgZXJyb3I6IGxvY2F0aW9uc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oXCJ2ZW5kb3JfbG9jYXRpb25zXCIpXG4gICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgLmVxKFwidmVuZG9yX2lkXCIsIHByb2ZpbGVEYXRhLmlkKTtcblxuICAgIGlmIChsb2NhdGlvbnNFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHZlbmRvciBsb2NhdGlvbnM6XCIsIGxvY2F0aW9uc0Vycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0TG9jYXRpb25zKGxvY2F0aW9uc0RhdGEgfHwgW10pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGZldGNoUHJvZmlsZTpcIiwgZXJyKTtcbiAgICBzZXRFcnJvcihcIkFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWRcIik7XG4gIH0gZmluYWxseSB7XG4gICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gIH1cbn07XG5cbiAgY29uc3Qgc2F2ZVByb2ZpbGUgPSBhc3luYyAoZGF0YToge1xuICAgIGJ1c2luZXNzX25hbWU6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgIGJ1c2luZXNzX2NhdGVnb3J5OiBzdHJpbmc7XG4gICAgZXZlbnRfdHlwZXM6IHN0cmluZ1tdO1xuICAgIGxvZ29fdXJsPzogc3RyaW5nIHwgbnVsbDtcbiAgICBjb250YWN0czogQXJyYXk8e1xuICAgICAgY29udGFjdF90eXBlOiBcImVtYWlsXCIgfCBcInBob25lXCI7XG4gICAgICBjb250YWN0X3ZhbHVlOiBzdHJpbmc7XG4gICAgICBpc19wcmltYXJ5OiBib29sZWFuO1xuICAgIH0+O1xuICAgIGxvY2F0aW9uczogc3RyaW5nW107XG4gIH0pID0+IHtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJObyB1c2VyIGZvdW5kXCIgfTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnRDb21wb25lbnRDbGllbnQoKTtcblxuICAgICAgbGV0IHZlbmRvclByb2ZpbGVJZDogc3RyaW5nO1xuXG4gICAgICBpZiAoIXByb2ZpbGUpIHtcbiAgICAgICAgLy8gTm8gcHJvZmlsZSBleGlzdHMsIGNyZWF0ZSBvbmVcbiAgICAgICAgY29uc29sZS5sb2coXCJObyB2ZW5kb3IgcHJvZmlsZSBmb3VuZCwgY3JlYXRpbmcgbmV3IG9uZS4uLlwiKTtcblxuICAgICAgICAvLyBHZW5lcmF0ZSB1bmlxdWUgc2x1ZyBmb3IgdGhlIHZlbmRvclxuICAgICAgICBsZXQgc2x1Zzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgZ2VuZXJhdGVVbmlxdWVTbHVnIH0gPSBhd2FpdCBpbXBvcnQoXCJAL2xpYi9zbHVnLXV0aWxzXCIpO1xuICAgICAgICAgIHNsdWcgPSBhd2FpdCBnZW5lcmF0ZVVuaXF1ZVNsdWcoZGF0YS5idXNpbmVzc19uYW1lKTtcbiAgICAgICAgfSBjYXRjaCAoc2x1Z0Vycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gZ2VuZXJhdGUgc2x1ZywgY3JlYXRpbmcgdmVuZG9yIHdpdGhvdXQgc2x1ZzonLCBzbHVnRXJyb3IpO1xuICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGhvdXQgc2x1ZyAtIGl0IHdpbGwgdXNlIElEIGZvciByb3V0aW5nXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGRhdGE6IG5ld1Byb2ZpbGUsIGVycm9yOiBjcmVhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbShcInZlbmRvcl9wcm9maWxlc1wiKVxuICAgICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgICAgdXNlcl9pZDogdXNlci5pZCxcbiAgICAgICAgICAgIGJ1c2luZXNzX25hbWU6IGRhdGEuYnVzaW5lc3NfbmFtZSxcbiAgICAgICAgICAgIC4uLihzbHVnICYmIHsgc2x1ZyB9KSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkYXRhLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgYnVzaW5lc3NfY2F0ZWdvcnk6IGRhdGEuYnVzaW5lc3NfY2F0ZWdvcnkgYXMgYW55LFxuICAgICAgICAgICAgZXZlbnRfdHlwZXM6IGRhdGEuZXZlbnRfdHlwZXMgYXMgYW55LFxuICAgICAgICAgICAgbG9nb191cmw6IGRhdGEubG9nb191cmwsXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgICAgaWYgKGNyZWF0ZUVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgdmVuZG9yIHByb2ZpbGU6XCIsIGNyZWF0ZUVycm9yKTtcbiAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiRmFpbGVkIHRvIGNyZWF0ZSBwcm9maWxlXCIgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZlbmRvclByb2ZpbGVJZCA9IG5ld1Byb2ZpbGUuaWQ7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVmVuZG9yIHByb2ZpbGUgY3JlYXRlZCB3aXRoIElEOlwiLCB2ZW5kb3JQcm9maWxlSWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUHJvZmlsZSBleGlzdHMsIHVwZGF0ZSBpdFxuICAgICAgICB2ZW5kb3JQcm9maWxlSWQgPSBwcm9maWxlLmlkO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVXBkYXRpbmcgZXhpc3RpbmcgdmVuZG9yIHByb2ZpbGUuLi5cIik7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgYnVzaW5lc3MgbmFtZSBjaGFuZ2VkIGFuZCByZWdlbmVyYXRlIHNsdWcgaWYgbmVlZGVkXG4gICAgICAgIGxldCB1cGRhdGVEYXRhOiBhbnkgPSB7XG4gICAgICAgICAgYnVzaW5lc3NfbmFtZTogZGF0YS5idXNpbmVzc19uYW1lLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBkYXRhLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIGJ1c2luZXNzX2NhdGVnb3J5OiBkYXRhLmJ1c2luZXNzX2NhdGVnb3J5IGFzIGFueSxcbiAgICAgICAgICBldmVudF90eXBlczogZGF0YS5ldmVudF90eXBlcyBhcyBhbnksXG4gICAgICAgICAgbG9nb191cmw6IGRhdGEubG9nb191cmwsXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChwcm9maWxlLmJ1c2luZXNzX25hbWUgIT09IGRhdGEuYnVzaW5lc3NfbmFtZSkge1xuICAgICAgICAgIC8vIEJ1c2luZXNzIG5hbWUgY2hhbmdlZCwgcmVnZW5lcmF0ZSBzbHVnXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2VuZXJhdGVVbmlxdWVTbHVnIH0gPSBhd2FpdCBpbXBvcnQoXCJAL2xpYi9zbHVnLXV0aWxzXCIpO1xuICAgICAgICAgICAgY29uc3QgbmV3U2x1ZyA9IGF3YWl0IGdlbmVyYXRlVW5pcXVlU2x1ZyhkYXRhLmJ1c2luZXNzX25hbWUsIHByb2ZpbGUuc2x1ZyB8fCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgdXBkYXRlRGF0YS5zbHVnID0gbmV3U2x1ZztcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBCdXNpbmVzcyBuYW1lIGNoYW5nZWQsIHJlZ2VuZXJhdGluZyBzbHVnOiAke25ld1NsdWd9YCk7XG4gICAgICAgICAgfSBjYXRjaCAoc2x1Z0Vycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byByZWdlbmVyYXRlIHNsdWcsIGtlZXBpbmcgZXhpc3Rpbmcgc2x1ZzonLCBzbHVnRXJyb3IpO1xuICAgICAgICAgICAgLy8gS2VlcCBleGlzdGluZyBzbHVnIG9yIGRvbid0IHVwZGF0ZSBpdFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgZGF0YTogdXBkYXRlUmVzdWx0LCBlcnJvcjogcHJvZmlsZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKFwidmVuZG9yX3Byb2ZpbGVzXCIpXG4gICAgICAgICAgLnVwZGF0ZSh1cGRhdGVEYXRhKVxuICAgICAgICAgIC5lcShcImlkXCIsIHByb2ZpbGUuaWQpXG4gICAgICAgICAgLnNlbGVjdCgpO1xuXG4gICAgICAgIGlmIChwcm9maWxlRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiRmFpbGVkIHRvIHVwZGF0ZSBwcm9maWxlXCIgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhcIvCfl5HvuI8gRGVsZXRpbmcgZXhpc3RpbmcgY29udGFjdHMgYW5kIGxvY2F0aW9ucy4uLlwiKTtcbiAgICAgIFxuICAgICAgLy8gRGVsZXRlIGNvbnRhY3RzIGZpcnN0IChvbmx5IGlmIHByb2ZpbGUgZXhpc3RlZCBiZWZvcmUpXG4gICAgICBpZiAocHJvZmlsZSkge1xuICAgICAgICBjb25zdCB7IGVycm9yOiBkZWxldGVDb250YWN0c0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKFwidmVuZG9yX2NvbnRhY3RzXCIpXG4gICAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgICAgLmVxKFwidmVuZG9yX2lkXCIsIHByb2ZpbGUuaWQpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+TniBDb250YWN0cyBkZWxldGUgZXJyb3I6XCIsIGRlbGV0ZUNvbnRhY3RzRXJyb3IpO1xuXG4gICAgICAgIGlmIChkZWxldGVDb250YWN0c0Vycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCLinYwgRmFpbGVkIHRvIGRlbGV0ZSBjb250YWN0czpcIiwgZGVsZXRlQ29udGFjdHNFcnJvcik7XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkZhaWxlZCB0byBkZWxldGUgZXhpc3RpbmcgY29udGFjdHNcIiB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coXCLinIUgQ29udGFjdHMgZGVsZXRlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICAgIFxuICAgICAgICAvLyBEZWxldGUgbG9jYXRpb25zXG4gICAgICAgIGNvbnN0IHsgZXJyb3I6IGRlbGV0ZUxvY2F0aW9uc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKFwidmVuZG9yX2xvY2F0aW9uc1wiKVxuICAgICAgICAgIC5kZWxldGUoKVxuICAgICAgICAgIC5lcShcInZlbmRvcl9pZFwiLCBwcm9maWxlLmlkKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk40gTG9jYXRpb25zIGRlbGV0ZSBlcnJvcjpcIiwgZGVsZXRlTG9jYXRpb25zRXJyb3IpO1xuXG4gICAgICAgIGlmIChkZWxldGVMb2NhdGlvbnNFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwi4p2MIEZhaWxlZCB0byBkZWxldGUgbG9jYXRpb25zOlwiLCBkZWxldGVMb2NhdGlvbnNFcnJvcik7XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkZhaWxlZCB0byBkZWxldGUgZXhpc3RpbmcgbG9jYXRpb25zXCIgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwi4pyFIExvY2F0aW9ucyBkZWxldGVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coXCLwn5OeIEluc2VydGluZyBuZXcgY29udGFjdHMuLi5cIik7XG4gICAgICBcbiAgICAgIC8vIEluc2VydCBuZXcgY29udGFjdHNcbiAgICAgIGlmIChkYXRhLmNvbnRhY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5OLIENvbnRhY3RzIHRvIGluc2VydDpcIiwgZGF0YS5jb250YWN0cyk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB7IGVycm9yOiBjb250YWN0c0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKFwidmVuZG9yX2NvbnRhY3RzXCIpXG4gICAgICAgICAgLmluc2VydChcbiAgICAgICAgICAgIGRhdGEuY29udGFjdHMubWFwKChjb250YWN0KSA9PiAoe1xuICAgICAgICAgICAgICB2ZW5kb3JfaWQ6IHZlbmRvclByb2ZpbGVJZCxcbiAgICAgICAgICAgICAgY29udGFjdF90eXBlOiBjb250YWN0LmNvbnRhY3RfdHlwZSxcbiAgICAgICAgICAgICAgY29udGFjdF92YWx1ZTogY29udGFjdC5jb250YWN0X3ZhbHVlLFxuICAgICAgICAgICAgICBpc19wcmltYXJ5OiBjb250YWN0LmlzX3ByaW1hcnksXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICApO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+TniBDb250YWN0cyBpbnNlcnQgZXJyb3I6XCIsIGNvbnRhY3RzRXJyb3IpO1xuXG4gICAgICAgIGlmIChjb250YWN0c0Vycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCLinYwgRmFpbGVkIHRvIGluc2VydCBjb250YWN0czpcIiwgY29udGFjdHNFcnJvcik7XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkZhaWxlZCB0byB1cGRhdGUgY29udGFjdHNcIiB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coXCLinIUgQ29udGFjdHMgaW5zZXJ0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCLihLnvuI8gTm8gY29udGFjdHMgdG8gaW5zZXJ0XCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhcIvCfk40gSW5zZXJ0aW5nIG5ldyBsb2NhdGlvbnMuLi5cIik7XG4gICAgICBcbiAgICAgIC8vIEluc2VydCBuZXcgbG9jYXRpb25zXG4gICAgICBpZiAoZGF0YS5sb2NhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIvCfl7rvuI8gTG9jYXRpb25zIHRvIGluc2VydDpcIiwgZGF0YS5sb2NhdGlvbnMpO1xuICAgICAgICBcbiAgICAgICAgLy8gVmFsaWRhdGUgbG9jYXRpb24gdmFsdWVzXG4gICAgICAgIGNvbnN0IHZhbGlkTG9jYXRpb25zID0gW1xuICAgICAgICAgIFwibmljb3NpYVwiLCBcImxpbWFzc29sXCIsIFwibGFybmFjYVwiLCBcInBhcGhvc1wiLCBcbiAgICAgICAgICBcInBsYXRyZXNcIiwgXCJwYXJhbGltbmlfYXlpYV9uYXBhXCIsIFwid2hvbGVfY3lwcnVzXCJcbiAgICAgICAgXTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGludmFsaWRMb2NhdGlvbnMgPSBkYXRhLmxvY2F0aW9ucy5maWx0ZXIoXG4gICAgICAgICAgbG9jYXRpb24gPT4gIXZhbGlkTG9jYXRpb25zLmluY2x1ZGVzKGxvY2F0aW9uKVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgaWYgKGludmFsaWRMb2NhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwi4p2MIEludmFsaWQgbG9jYXRpb24gdmFsdWVzOlwiLCBpbnZhbGlkTG9jYXRpb25zKTtcbiAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGBJbnZhbGlkIGxvY2F0aW9uIHZhbHVlczogJHtpbnZhbGlkTG9jYXRpb25zLmpvaW4oXCIsIFwiKX1gIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uRGF0YSA9IGRhdGEubG9jYXRpb25zLm1hcCgobG9jYXRpb24pID0+ICh7XG4gICAgICAgICAgdmVuZG9yX2lkOiB2ZW5kb3JQcm9maWxlSWQsXG4gICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICB9KSk7XG4gIFxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfl7rvuI8gTG9jYXRpb24gZGF0YSB0byBpbnNlcnQ6XCIsIGxvY2F0aW9uRGF0YSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB7IGRhdGE6IGluc2VydGVkTG9jYXRpb25zLCBlcnJvcjogbG9jYXRpb25zRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oXCJ2ZW5kb3JfbG9jYXRpb25zXCIpXG4gICAgICAgICAgLmluc2VydChsb2NhdGlvbkRhdGEpXG4gICAgICAgICAgLnNlbGVjdCgpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+TjSBMb2NhdGlvbnMgaW5zZXJ0IGVycm9yOlwiLCBsb2NhdGlvbnNFcnJvcik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+TjSBJbnNlcnRlZCBsb2NhdGlvbnM6XCIsIGluc2VydGVkTG9jYXRpb25zKTtcblxuICAgICAgICBpZiAobG9jYXRpb25zRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIuKdjCBGYWlsZWQgdG8gaW5zZXJ0IGxvY2F0aW9uczpcIiwgbG9jYXRpb25zRXJyb3IpO1xuICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJGYWlsZWQgdG8gdXBkYXRlIGxvY2F0aW9uc1wiIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKFwi4pyFIExvY2F0aW9ucyBpbnNlcnRlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIuKEue+4jyBObyBsb2NhdGlvbnMgdG8gaW5zZXJ0XCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhcIvCflIQgUmVmZXRjaGluZyBwcm9maWxlIGRhdGEuLi5cIik7XG4gICAgICBcbiAgICAgIC8vIFJlZmV0Y2ggZGF0YSB0byB1cGRhdGUgdGhlIFVJXG4gICAgICBhd2FpdCBmZXRjaFByb2ZpbGUoKTtcblxuICAgICAgY29uc29sZS5sb2coXCLwn46JIFByb2ZpbGUgc2F2ZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5IVwiKTtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+SpSBFeGNlcHRpb24gaW4gc2F2ZVByb2ZpbGU6XCIsIGVycik7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZFwiIH07XG4gICAgfVxuICB9O1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZmV0Y2hQcm9maWxlKCk7XG4gIH0sIFt1c2VyXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBwcm9maWxlLFxuICAgIGNvbnRhY3RzLFxuICAgIGxvY2F0aW9ucyxcbiAgICBsb2FkaW5nLFxuICAgIGVycm9yLFxuICAgIHJlZmV0Y2g6IGZldGNoUHJvZmlsZSxcbiAgICBzYXZlUHJvZmlsZSxcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUF1dGgiLCJjcmVhdGVDbGllbnRDb21wb25lbnRDbGllbnQiLCJ1c2VWZW5kb3JQcm9maWxlIiwidXNlciIsInByb2ZpbGUiLCJzZXRQcm9maWxlIiwiY29udGFjdHMiLCJzZXRDb250YWN0cyIsImxvY2F0aW9ucyIsInNldExvY2F0aW9ucyIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImZldGNoUHJvZmlsZSIsInN1cGFiYXNlIiwiZGF0YSIsInVzZXJQcm9maWxlIiwidXNlclByb2ZpbGVFcnJvciIsImZyb20iLCJzZWxlY3QiLCJlcSIsImlkIiwic2luZ2xlIiwiY29uc29sZSIsInVzZXJfdHlwZSIsImxvZyIsInByb2ZpbGVEYXRhIiwidmVuZG9yUHJvZmlsZUVycm9yIiwibWF4UmV0cmllcyIsInJldHJ5RGVsYXkiLCJhdHRlbXB0IiwicHJvZmlsZUVycm9yIiwiY29kZSIsIm1lc3NhZ2UiLCJpbmNsdWRlcyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb250YWN0c0RhdGEiLCJjb250YWN0c0Vycm9yIiwib3JkZXIiLCJhc2NlbmRpbmciLCJsb2NhdGlvbnNEYXRhIiwibG9jYXRpb25zRXJyb3IiLCJlcnIiLCJzYXZlUHJvZmlsZSIsInN1Y2Nlc3MiLCJ2ZW5kb3JQcm9maWxlSWQiLCJzbHVnIiwiZ2VuZXJhdGVVbmlxdWVTbHVnIiwiYnVzaW5lc3NfbmFtZSIsInNsdWdFcnJvciIsIndhcm4iLCJuZXdQcm9maWxlIiwiY3JlYXRlRXJyb3IiLCJpbnNlcnQiLCJ1c2VyX2lkIiwiZGVzY3JpcHRpb24iLCJidXNpbmVzc19jYXRlZ29yeSIsImV2ZW50X3R5cGVzIiwibG9nb191cmwiLCJ1cGRhdGVEYXRhIiwidXBkYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIm5ld1NsdWciLCJ1bmRlZmluZWQiLCJ1cGRhdGVSZXN1bHQiLCJ1cGRhdGUiLCJkZWxldGVDb250YWN0c0Vycm9yIiwiZGVsZXRlIiwiZGVsZXRlTG9jYXRpb25zRXJyb3IiLCJsZW5ndGgiLCJtYXAiLCJjb250YWN0IiwidmVuZG9yX2lkIiwiY29udGFjdF90eXBlIiwiY29udGFjdF92YWx1ZSIsImlzX3ByaW1hcnkiLCJ2YWxpZExvY2F0aW9ucyIsImludmFsaWRMb2NhdGlvbnMiLCJmaWx0ZXIiLCJsb2NhdGlvbiIsImpvaW4iLCJsb2NhdGlvbkRhdGEiLCJpbnNlcnRlZExvY2F0aW9ucyIsInJlZmV0Y2giXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useVendorProfile.ts\n"));

/***/ })

});