"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/profile/page",{

/***/ "(app-pages-browser)/./src/hooks/useVendorProfile.ts":
/*!***************************************!*\
  !*** ./src/hooks/useVendorProfile.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useVendorProfile: () => (/* binding */ useVendorProfile)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _contexts_AuthContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/contexts/AuthContext */ \"(app-pages-browser)/./src/contexts/AuthContext.tsx\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n\n\n\nfunction useVendorProfile() {\n    const { user } = (0,_contexts_AuthContext__WEBPACK_IMPORTED_MODULE_1__.useAuth)();\n    const [profile, setProfile] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [contacts, setContacts] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [locations, setLocations] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchProfile = async ()=>{\n        if (!user) {\n            setLoading(false);\n            return;\n        }\n        try {\n            // First check if user is a vendor by querying their profile\n            const supabase = (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.createClientComponentClient)();\n            const { data: userProfile, error: userProfileError } = await supabase.from(\"profiles\").select(\"user_type\").eq(\"id\", user.id).single();\n            if (userProfileError) {\n                console.error(\"Error fetching user profile:\", userProfileError);\n                setError(\"Failed to verify user type\");\n                setLoading(false);\n                return;\n            }\n            // Only proceed if user is a vendor\n            if (userProfile.user_type !== \"vendor\") {\n                console.log(\"User is not a vendor, skipping vendor profile fetch\");\n                setProfile(null);\n                setContacts([]);\n                setLocations([]);\n                setLoading(false);\n                return;\n            }\n            // Now fetch vendor profile with retry logic for timing issues\n            let profileData = null;\n            let profileError = null;\n            const maxRetries = 3;\n            const retryDelay = 1000;\n            for(let attempt = 1; attempt <= maxRetries; attempt++){\n                const { data, error } = await supabase.from(\"vendor_profiles\").select(\"*\").eq(\"user_id\", user.id).single();\n                profileData = data;\n                profileError = error;\n                if (profileError) {\n                    var _profileError_message;\n                    console.error(\"Error fetching vendor profile (attempt \".concat(attempt, \"/\").concat(maxRetries, \"):\"), profileError);\n                    // If vendor profile doesn't exist, that's expected for new vendors\n                    if (profileError.code === 'PGRST116') {\n                        console.log(\"Vendor profile doesn't exist yet - this is normal for new vendors\");\n                        setProfile(null);\n                        setContacts([]);\n                        setLocations([]);\n                        setError(null);\n                        setLoading(false);\n                        return;\n                    }\n                    // If this is a 406 error and we have retries left, wait and try again\n                    if (((_profileError_message = profileError.message) === null || _profileError_message === void 0 ? void 0 : _profileError_message.includes('406')) && attempt < maxRetries) {\n                        console.log(\"Received 406 error, retrying in \".concat(retryDelay, \"ms (attempt \").concat(attempt, \"/\").concat(maxRetries, \")\"));\n                        await new Promise((resolve)=>setTimeout(resolve, retryDelay));\n                        continue;\n                    }\n                    break;\n                } else {\n                    break;\n                }\n            }\n            if (profileError) {\n                console.error(\"Final error fetching vendor profile:\", JSON.stringify(profileError, null, 2));\n                setError(\"Failed to load profile data. Please try refreshing the page.\");\n                setLoading(false);\n                return;\n            }\n            setProfile(profileData);\n            // Fetch vendor contacts\n            const { data: contactsData, error: contactsError } = await supabase.from(\"vendor_contacts\").select(\"*\").eq(\"vendor_id\", profileData.id).order(\"is_primary\", {\n                ascending: false\n            });\n            if (contactsError) {\n                console.error(\"Error fetching vendor contacts:\", contactsError);\n            } else {\n                setContacts(contactsData || []);\n            }\n            // Fetch vendor locations\n            const { data: locationsData, error: locationsError } = await supabase.from(\"vendor_locations\").select(\"*\").eq(\"vendor_id\", profileData.id);\n            if (locationsError) {\n                console.error(\"Error fetching vendor locations:\", locationsError);\n            } else {\n                setLocations(locationsData || []);\n            }\n        } catch (err) {\n            console.error(\"Error in fetchProfile:\", err);\n            setError(\"An unexpected error occurred\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    const saveProfile = async (data)=>{\n        if (!user) {\n            return {\n                success: false,\n                error: \"No user found\"\n            };\n        }\n        try {\n            const supabase = (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.createClientComponentClient)();\n            let vendorProfileId;\n            if (!profile) {\n                // No profile exists, create one\n                console.log(\"No vendor profile found, creating new one...\");\n                // Generate unique slug for the vendor\n                let slug;\n                try {\n                    const { generateUniqueSlug } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_lib_slug-utils_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/slug-utils */ \"(app-pages-browser)/./src/lib/slug-utils.ts\"));\n                    slug = await generateUniqueSlug(data.business_name);\n                } catch (slugError) {\n                    console.warn('Failed to generate slug, creating vendor without slug:', slugError);\n                // Continue without slug - it will use ID for routing\n                }\n                const { data: newProfile, error: createError } = await supabase.from(\"vendor_profiles\").insert({\n                    user_id: user.id,\n                    business_name: data.business_name,\n                    ...slug && {\n                        slug\n                    },\n                    description: data.description,\n                    business_category: data.business_category,\n                    event_types: data.event_types,\n                    logo_url: data.logo_url\n                }).select().single();\n                if (createError) {\n                    console.error(\"Failed to create vendor profile:\", createError);\n                    return {\n                        success: false,\n                        error: \"Failed to create profile\"\n                    };\n                }\n                vendorProfileId = newProfile.id;\n                console.log(\"Vendor profile created with ID:\", vendorProfileId);\n            } else {\n                // Profile exists, update it\n                vendorProfileId = profile.id;\n                console.log(\"Updating existing vendor profile...\");\n                // Check if business name changed and regenerate slug if needed\n                let updateData = {\n                    business_name: data.business_name,\n                    description: data.description,\n                    business_category: data.business_category,\n                    event_types: data.event_types,\n                    logo_url: data.logo_url,\n                    updated_at: new Date().toISOString()\n                };\n                if (profile.business_name !== data.business_name) {\n                    // Business name changed, regenerate slug\n                    try {\n                        const { generateUniqueSlug } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_lib_slug-utils_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/slug-utils */ \"(app-pages-browser)/./src/lib/slug-utils.ts\"));\n                        const newSlug = await generateUniqueSlug(data.business_name, profile.slug || undefined);\n                        updateData.slug = newSlug;\n                        console.log(\"Business name changed, regenerating slug: \".concat(newSlug));\n                    } catch (slugError) {\n                        console.warn('Failed to regenerate slug, keeping existing slug:', slugError);\n                    // Keep existing slug or don't update it\n                    }\n                }\n                const { data: updateResult, error: profileError } = await supabase.from(\"vendor_profiles\").update(updateData).eq(\"id\", profile.id).select();\n                if (profileError) {\n                    return {\n                        success: false,\n                        error: \"Failed to update profile\"\n                    };\n                }\n            }\n            console.log(\"🗑️ Deleting existing contacts and locations...\");\n            // Delete contacts first (only if profile existed before)\n            if (profile) {\n                const { error: deleteContactsError } = await supabase.from(\"vendor_contacts\").delete().eq(\"vendor_id\", profile.id);\n                console.log(\"📞 Contacts delete error:\", deleteContactsError);\n                if (deleteContactsError) {\n                    console.log(\"❌ Failed to delete contacts:\", deleteContactsError);\n                    return {\n                        success: false,\n                        error: \"Failed to delete existing contacts\"\n                    };\n                }\n                console.log(\"✅ Contacts deleted successfully\");\n                // Delete locations\n                const { error: deleteLocationsError } = await supabase.from(\"vendor_locations\").delete().eq(\"vendor_id\", profile.id);\n                console.log(\"📍 Locations delete error:\", deleteLocationsError);\n                if (deleteLocationsError) {\n                    console.log(\"❌ Failed to delete locations:\", deleteLocationsError);\n                    return {\n                        success: false,\n                        error: \"Failed to delete existing locations\"\n                    };\n                }\n                console.log(\"✅ Locations deleted successfully\");\n            }\n            console.log(\"📞 Inserting new contacts...\");\n            // Insert new contacts\n            if (data.contacts.length > 0) {\n                console.log(\"📋 Contacts to insert:\", data.contacts);\n                const { error: contactsError } = await supabase.from(\"vendor_contacts\").insert(data.contacts.map((contact)=>({\n                        vendor_id: vendorProfileId,\n                        contact_type: contact.contact_type,\n                        contact_value: contact.contact_value,\n                        is_primary: contact.is_primary\n                    })));\n                console.log(\"📞 Contacts insert error:\", contactsError);\n                if (contactsError) {\n                    console.log(\"❌ Failed to insert contacts:\", contactsError);\n                    return {\n                        success: false,\n                        error: \"Failed to update contacts\"\n                    };\n                }\n                console.log(\"✅ Contacts inserted successfully\");\n            } else {\n                console.log(\"ℹ️ No contacts to insert\");\n            }\n            console.log(\"📍 Inserting new locations...\");\n            // Insert new locations\n            if (data.locations.length > 0) {\n                console.log(\"🗺️ Locations to insert:\", data.locations);\n                // Validate location values\n                const validLocations = [\n                    \"nicosia\",\n                    \"limassol\",\n                    \"larnaca\",\n                    \"paphos\",\n                    \"platres\",\n                    \"paralimni_ayia_napa\",\n                    \"whole_cyprus\"\n                ];\n                const invalidLocations = data.locations.filter((location)=>!validLocations.includes(location));\n                if (invalidLocations.length > 0) {\n                    console.log(\"❌ Invalid location values:\", invalidLocations);\n                    return {\n                        success: false,\n                        error: \"Invalid location values: \".concat(invalidLocations.join(\", \"))\n                    };\n                }\n                const locationData = data.locations.map((location)=>({\n                        vendor_id: vendorProfileId,\n                        location: location\n                    }));\n                console.log(\"🗺️ Location data to insert:\", locationData);\n                const { data: insertedLocations, error: locationsError } = await supabase.from(\"vendor_locations\").insert(locationData).select();\n                console.log(\"📍 Locations insert error:\", locationsError);\n                console.log(\"📍 Inserted locations:\", insertedLocations);\n                if (locationsError) {\n                    console.log(\"❌ Failed to insert locations:\", locationsError);\n                    return {\n                        success: false,\n                        error: \"Failed to update locations\"\n                    };\n                }\n                console.log(\"✅ Locations inserted successfully\");\n            } else {\n                console.log(\"ℹ️ No locations to insert\");\n            }\n            console.log(\"🔄 Refetching profile data...\");\n            // Refetch data to update the UI\n            await fetchProfile();\n            console.log(\"🎉 Profile save completed successfully!\");\n            return {\n                success: true\n            };\n        } catch (err) {\n            console.log(\"💥 Exception in saveProfile:\", err);\n            return {\n                success: false,\n                error: \"An unexpected error occurred\"\n            };\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useVendorProfile.useEffect\": ()=>{\n            fetchProfile();\n        }\n    }[\"useVendorProfile.useEffect\"], [\n        user\n    ]);\n    return {\n        profile,\n        contacts,\n        locations,\n        loading,\n        error,\n        refetch: fetchProfile,\n        saveProfile\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VWZW5kb3JQcm9maWxlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTRDO0FBQ0s7QUFDc0I7QUFxRGhFLFNBQVNJO0lBQ2QsTUFBTSxFQUFFQyxJQUFJLEVBQUUsR0FBR0gsOERBQU9BO0lBQ3hCLE1BQU0sQ0FBQ0ksU0FBU0MsV0FBVyxHQUFHUCwrQ0FBUUEsQ0FBdUI7SUFDN0QsTUFBTSxDQUFDUSxVQUFVQyxZQUFZLEdBQUdULCtDQUFRQSxDQUFrQixFQUFFO0lBQzVELE1BQU0sQ0FBQ1UsV0FBV0MsYUFBYSxHQUFHWCwrQ0FBUUEsQ0FBbUIsRUFBRTtJQUMvRCxNQUFNLENBQUNZLFNBQVNDLFdBQVcsR0FBR2IsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDYyxPQUFPQyxTQUFTLEdBQUdmLCtDQUFRQSxDQUFnQjtJQUVsRCxNQUFNZ0IsZUFBZTtRQUNuQixJQUFJLENBQUNYLE1BQU07WUFDVFEsV0FBVztZQUNYO1FBQ0Y7UUFFQSxJQUFJO1lBQ0YsNERBQTREO1lBQzVELE1BQU1JLFdBQVdkLDBFQUEyQkE7WUFDNUMsTUFBTSxFQUFFZSxNQUFNQyxXQUFXLEVBQUVMLE9BQU9NLGdCQUFnQixFQUFFLEdBQUcsTUFBTUgsU0FDMURJLElBQUksQ0FBQyxZQUNMQyxNQUFNLENBQUMsYUFDUEMsRUFBRSxDQUFDLE1BQU1sQixLQUFLbUIsRUFBRSxFQUNoQkMsTUFBTTtZQUVULElBQUlMLGtCQUFrQjtnQkFDcEJNLFFBQVFaLEtBQUssQ0FBQyxnQ0FBZ0NNO2dCQUM5Q0wsU0FBUztnQkFDVEYsV0FBVztnQkFDWDtZQUNGO1lBRUEsbUNBQW1DO1lBQ25DLElBQUlNLFlBQVlRLFNBQVMsS0FBSyxVQUFVO2dCQUN0Q0QsUUFBUUUsR0FBRyxDQUFDO2dCQUNackIsV0FBVztnQkFDWEUsWUFBWSxFQUFFO2dCQUNkRSxhQUFhLEVBQUU7Z0JBQ2ZFLFdBQVc7Z0JBQ1g7WUFDRjtZQUVBLDhEQUE4RDtZQUNo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Q0FBZ0M7WUFDaEMsTUFBTVo7WUFFTlUsUUFBUUUsR0FBRyxDQUFDO1lBQ1osT0FBTztnQkFBRXNCLFNBQVM7WUFBSztRQUN6QixFQUFFLE9BQU9GLEtBQUs7WUFDWnRCLFFBQVFFLEdBQUcsQ0FBQyxnQ0FBZ0NvQjtZQUM1QyxPQUFPO2dCQUFFRSxTQUFTO2dCQUFPcEMsT0FBTztZQUErQjtRQUNqRTtJQUNGO0lBRUFiLGdEQUFTQTtzQ0FBQztZQUNSZTtRQUNGO3FDQUFHO1FBQUNYO0tBQUs7SUFFVCxPQUFPO1FBQ0xDO1FBQ0FFO1FBQ0FFO1FBQ0FFO1FBQ0FFO1FBQ0E0RSxTQUFTMUU7UUFDVGlDO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2RhdmlkYmFsaWFuL0Rlc2t0b3AvbW9tZW50bW9pLXZvaWQvc3JjL2hvb2tzL3VzZVZlbmRvclByb2ZpbGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlQXV0aCB9IGZyb20gXCJAL2NvbnRleHRzL0F1dGhDb250ZXh0XCI7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnRDb21wb25lbnRDbGllbnQsIHN1cGFiYXNlIH0gZnJvbSBcIkAvbGliL3N1cGFiYXNlXCI7XG5cbmludGVyZmFjZSBWZW5kb3JQcm9maWxlIHtcbiAgaWQ6IHN0cmluZztcbiAgdXNlcl9pZDogc3RyaW5nO1xuICBzbHVnOiBzdHJpbmcgfCBudWxsO1xuICBidXNpbmVzc19uYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmcgfCBudWxsO1xuICBsb2dvX3VybDogc3RyaW5nIHwgbnVsbDtcbiAgdmVyaWZpZWQ6IGJvb2xlYW47XG4gIGJ1c2luZXNzX2NhdGVnb3J5OiBzdHJpbmc7XG4gIGV2ZW50X3R5cGVzOiBzdHJpbmdbXTtcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICB1cGRhdGVkX2F0OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBWZW5kb3JDb250YWN0IHtcbiAgaWQ6IHN0cmluZztcbiAgdmVuZG9yX2lkOiBzdHJpbmc7XG4gIGNvbnRhY3RfdHlwZTogXCJlbWFpbFwiIHwgXCJwaG9uZVwiO1xuICBjb250YWN0X3ZhbHVlOiBzdHJpbmc7XG4gIGlzX3ByaW1hcnk6IGJvb2xlYW47XG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFZlbmRvckxvY2F0aW9uIHtcbiAgaWQ6IHN0cmluZztcbiAgdmVuZG9yX2lkOiBzdHJpbmc7XG4gIGxvY2F0aW9uOiBzdHJpbmc7XG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFVzZVZlbmRvclByb2ZpbGVSZXR1cm4ge1xuICBwcm9maWxlOiBWZW5kb3JQcm9maWxlIHwgbnVsbDtcbiAgY29udGFjdHM6IFZlbmRvckNvbnRhY3RbXTtcbiAgbG9jYXRpb25zOiBWZW5kb3JMb2NhdGlvbltdO1xuICBsb2FkaW5nOiBib29sZWFuO1xuICBlcnJvcjogc3RyaW5nIHwgbnVsbDtcbiAgcmVmZXRjaDogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgc2F2ZVByb2ZpbGU6IChkYXRhOiB7XG4gICAgYnVzaW5lc3NfbmFtZTogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgYnVzaW5lc3NfY2F0ZWdvcnk6IHN0cmluZztcbiAgICBldmVudF90eXBlczogc3RyaW5nW107XG4gICAgY29udGFjdHM6IEFycmF5PHtcbiAgICAgIGNvbnRhY3RfdHlwZTogXCJlbWFpbFwiIHwgXCJwaG9uZVwiO1xuICAgICAgY29udGFjdF92YWx1ZTogc3RyaW5nO1xuICAgICAgaXNfcHJpbWFyeTogYm9vbGVhbjtcbiAgICB9PjtcbiAgICBsb2NhdGlvbnM6IHN0cmluZ1tdO1xuICB9KSA9PiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfT47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VWZW5kb3JQcm9maWxlKCk6IFVzZVZlbmRvclByb2ZpbGVSZXR1cm4ge1xuICBjb25zdCB7IHVzZXIgfSA9IHVzZUF1dGgoKTtcbiAgY29uc3QgW3Byb2ZpbGUsIHNldFByb2ZpbGVdID0gdXNlU3RhdGU8VmVuZG9yUHJvZmlsZSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbY29udGFjdHMsIHNldENvbnRhY3RzXSA9IHVzZVN0YXRlPFZlbmRvckNvbnRhY3RbXT4oW10pO1xuICBjb25zdCBbbG9jYXRpb25zLCBzZXRMb2NhdGlvbnNdID0gdXNlU3RhdGU8VmVuZG9yTG9jYXRpb25bXT4oW10pO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBmZXRjaFByb2ZpbGUgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdXNlciBpcyBhIHZlbmRvciBieSBxdWVyeWluZyB0aGVpciBwcm9maWxlXG4gICAgICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudENvbXBvbmVudENsaWVudCgpO1xuICAgICAgY29uc3QgeyBkYXRhOiB1c2VyUHJvZmlsZSwgZXJyb3I6IHVzZXJQcm9maWxlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKFwicHJvZmlsZXNcIilcbiAgICAgICAgLnNlbGVjdChcInVzZXJfdHlwZVwiKVxuICAgICAgICAuZXEoXCJpZFwiLCB1c2VyLmlkKVxuICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgIGlmICh1c2VyUHJvZmlsZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyB1c2VyIHByb2ZpbGU6XCIsIHVzZXJQcm9maWxlRXJyb3IpO1xuICAgICAgICBzZXRFcnJvcihcIkZhaWxlZCB0byB2ZXJpZnkgdXNlciB0eXBlXCIpO1xuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBPbmx5IHByb2NlZWQgaWYgdXNlciBpcyBhIHZlbmRvclxuICAgICAgaWYgKHVzZXJQcm9maWxlLnVzZXJfdHlwZSAhPT0gXCJ2ZW5kb3JcIikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVzZXIgaXMgbm90IGEgdmVuZG9yLCBza2lwcGluZyB2ZW5kb3IgcHJvZmlsZSBmZXRjaFwiKTtcbiAgICAgICAgc2V0UHJvZmlsZShudWxsKTtcbiAgICAgICAgc2V0Q29udGFjdHMoW10pO1xuICAgICAgICBzZXRMb2NhdGlvbnMoW10pO1xuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3cgZmV0Y2ggdmVuZG9yIHByb2ZpbGUgd2l0aCByZXRyeSBsb2dpYyBmb3IgdGltaW5nIGlzc3Vlc1xuICAgIGxldCBwcm9maWxlRGF0YSA9IG51bGw7XG4gICAgbGV0IHByb2ZpbGVFcnJvciA9IG51bGw7XG4gICAgY29uc3QgbWF4UmV0cmllcyA9IDM7XG4gICAgY29uc3QgcmV0cnlEZWxheSA9IDEwMDA7XG5cbiAgICBmb3IgKGxldCBhdHRlbXB0ID0gMTsgYXR0ZW1wdCA8PSBtYXhSZXRyaWVzOyBhdHRlbXB0KyspIHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKFwidmVuZG9yX3Byb2ZpbGVzXCIpXG4gICAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAgIC5lcShcInVzZXJfaWRcIiwgdXNlci5pZClcbiAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICBwcm9maWxlRGF0YSA9IGRhdGE7XG4gICAgICBwcm9maWxlRXJyb3IgPSBlcnJvcjtcblxuICAgICAgaWYgKHByb2ZpbGVFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyB2ZW5kb3IgcHJvZmlsZSAoYXR0ZW1wdCAke2F0dGVtcHR9LyR7bWF4UmV0cmllc30pOmAsIHByb2ZpbGVFcnJvcik7XG5cbiAgICAgICAgLy8gSWYgdmVuZG9yIHByb2ZpbGUgZG9lc24ndCBleGlzdCwgdGhhdCdzIGV4cGVjdGVkIGZvciBuZXcgdmVuZG9yc1xuICAgICAgICBpZiAocHJvZmlsZUVycm9yLmNvZGUgPT09ICdQR1JTVDExNicpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlZlbmRvciBwcm9maWxlIGRvZXNuJ3QgZXhpc3QgeWV0IC0gdGhpcyBpcyBub3JtYWwgZm9yIG5ldyB2ZW5kb3JzXCIpO1xuICAgICAgICAgIHNldFByb2ZpbGUobnVsbCk7XG4gICAgICAgICAgc2V0Q29udGFjdHMoW10pO1xuICAgICAgICAgIHNldExvY2F0aW9ucyhbXSk7XG4gICAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIDQwNiBlcnJvciBhbmQgd2UgaGF2ZSByZXRyaWVzIGxlZnQsIHdhaXQgYW5kIHRyeSBhZ2FpblxuICAgICAgICBpZiAocHJvZmlsZUVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCc0MDYnKSAmJiBhdHRlbXB0IDwgbWF4UmV0cmllcykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBSZWNlaXZlZCA0MDYgZXJyb3IsIHJldHJ5aW5nIGluICR7cmV0cnlEZWxheX1tcyAoYXR0ZW1wdCAke2F0dGVtcHR9LyR7bWF4UmV0cmllc30pYCk7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHJldHJ5RGVsYXkpKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlJ3ZlIGV4aGF1c3RlZCByZXRyaWVzIG9yIGl0J3MgYSBkaWZmZXJlbnQgZXJyb3IsIGJyZWFrXG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3VjY2VzcywgYnJlYWsgb3V0IG9mIHJldHJ5IGxvb3BcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2ZpbGVFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZpbmFsIGVycm9yIGZldGNoaW5nIHZlbmRvciBwcm9maWxlOlwiLCBKU09OLnN0cmluZ2lmeShwcm9maWxlRXJyb3IsIG51bGwsIDIpKTtcbiAgICAgIHNldEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgcHJvZmlsZSBkYXRhLiBQbGVhc2UgdHJ5IHJlZnJlc2hpbmcgdGhlIHBhZ2UuXCIpO1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0UHJvZmlsZShwcm9maWxlRGF0YSk7XG5cbiAgICAvLyBGZXRjaCB2ZW5kb3IgY29udGFjdHNcbiAgICBjb25zdCB7IGRhdGE6IGNvbnRhY3RzRGF0YSwgZXJyb3I6IGNvbnRhY3RzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcInZlbmRvcl9jb250YWN0c1wiKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5lcShcInZlbmRvcl9pZFwiLCBwcm9maWxlRGF0YS5pZClcbiAgICAgIC5vcmRlcihcImlzX3ByaW1hcnlcIiwgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xuXG4gICAgaWYgKGNvbnRhY3RzRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyB2ZW5kb3IgY29udGFjdHM6XCIsIGNvbnRhY3RzRXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRDb250YWN0cyhjb250YWN0c0RhdGEgfHwgW10pO1xuICAgIH1cblxuICAgIC8vIEZldGNoIHZlbmRvciBsb2NhdGlvbnNcbiAgICBjb25zdCB7IGRhdGE6IGxvY2F0aW9uc0RhdGEsIGVycm9yOiBsb2NhdGlvbnNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwidmVuZG9yX2xvY2F0aW9uc1wiKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5lcShcInZlbmRvcl9pZFwiLCBwcm9maWxlRGF0YS5pZCk7XG5cbiAgICBpZiAobG9jYXRpb25zRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyB2ZW5kb3IgbG9jYXRpb25zOlwiLCBsb2NhdGlvbnNFcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldExvY2F0aW9ucyhsb2NhdGlvbnNEYXRhIHx8IFtdKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBmZXRjaFByb2ZpbGU6XCIsIGVycik7XG4gICAgc2V0RXJyb3IoXCJBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkXCIpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICB9XG59O1xuXG4gIGNvbnN0IHNhdmVQcm9maWxlID0gYXN5bmMgKGRhdGE6IHtcbiAgICBidXNpbmVzc19uYW1lOiBzdHJpbmc7XG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgICBidXNpbmVzc19jYXRlZ29yeTogc3RyaW5nO1xuICAgIGV2ZW50X3R5cGVzOiBzdHJpbmdbXTtcbiAgICBsb2dvX3VybD86IHN0cmluZyB8IG51bGw7XG4gICAgY29udGFjdHM6IEFycmF5PHtcbiAgICAgIGNvbnRhY3RfdHlwZTogXCJlbWFpbFwiIHwgXCJwaG9uZVwiO1xuICAgICAgY29udGFjdF92YWx1ZTogc3RyaW5nO1xuICAgICAgaXNfcHJpbWFyeTogYm9vbGVhbjtcbiAgICB9PjtcbiAgICBsb2NhdGlvbnM6IHN0cmluZ1tdO1xuICB9KSA9PiB7XG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiTm8gdXNlciBmb3VuZFwiIH07XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50Q29tcG9uZW50Q2xpZW50KCk7XG5cbiAgICAgIGxldCB2ZW5kb3JQcm9maWxlSWQ6IHN0cmluZztcblxuICAgICAgaWYgKCFwcm9maWxlKSB7XG4gICAgICAgIC8vIE5vIHByb2ZpbGUgZXhpc3RzLCBjcmVhdGUgb25lXG4gICAgICAgIGNvbnNvbGUubG9nKFwiTm8gdmVuZG9yIHByb2ZpbGUgZm91bmQsIGNyZWF0aW5nIG5ldyBvbmUuLi5cIik7XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgdW5pcXVlIHNsdWcgZm9yIHRoZSB2ZW5kb3JcbiAgICAgICAgbGV0IHNsdWc6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IGdlbmVyYXRlVW5pcXVlU2x1ZyB9ID0gYXdhaXQgaW1wb3J0KFwiQC9saWIvc2x1Zy11dGlsc1wiKTtcbiAgICAgICAgICBzbHVnID0gYXdhaXQgZ2VuZXJhdGVVbmlxdWVTbHVnKGRhdGEuYnVzaW5lc3NfbmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKHNsdWdFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGdlbmVyYXRlIHNsdWcsIGNyZWF0aW5nIHZlbmRvciB3aXRob3V0IHNsdWc6Jywgc2x1Z0Vycm9yKTtcbiAgICAgICAgICAvLyBDb250aW51ZSB3aXRob3V0IHNsdWcgLSBpdCB3aWxsIHVzZSBJRCBmb3Igcm91dGluZ1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBkYXRhOiBuZXdQcm9maWxlLCBlcnJvcjogY3JlYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oXCJ2ZW5kb3JfcHJvZmlsZXNcIilcbiAgICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgICAgICBidXNpbmVzc19uYW1lOiBkYXRhLmJ1c2luZXNzX25hbWUsXG4gICAgICAgICAgICAuLi4oc2x1ZyAmJiB7IHNsdWcgfSksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZGF0YS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGJ1c2luZXNzX2NhdGVnb3J5OiBkYXRhLmJ1c2luZXNzX2NhdGVnb3J5IGFzIGFueSxcbiAgICAgICAgICAgIGV2ZW50X3R5cGVzOiBkYXRhLmV2ZW50X3R5cGVzIGFzIGFueSxcbiAgICAgICAgICAgIGxvZ29fdXJsOiBkYXRhLmxvZ29fdXJsLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICAgIGlmIChjcmVhdGVFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIHZlbmRvciBwcm9maWxlOlwiLCBjcmVhdGVFcnJvcik7XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkZhaWxlZCB0byBjcmVhdGUgcHJvZmlsZVwiIH07XG4gICAgICAgIH1cblxuICAgICAgICB2ZW5kb3JQcm9maWxlSWQgPSBuZXdQcm9maWxlLmlkO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlZlbmRvciBwcm9maWxlIGNyZWF0ZWQgd2l0aCBJRDpcIiwgdmVuZG9yUHJvZmlsZUlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFByb2ZpbGUgZXhpc3RzLCB1cGRhdGUgaXRcbiAgICAgICAgdmVuZG9yUHJvZmlsZUlkID0gcHJvZmlsZS5pZDtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIlVwZGF0aW5nIGV4aXN0aW5nIHZlbmRvciBwcm9maWxlLi4uXCIpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGJ1c2luZXNzIG5hbWUgY2hhbmdlZCBhbmQgcmVnZW5lcmF0ZSBzbHVnIGlmIG5lZWRlZFxuICAgICAgICBsZXQgdXBkYXRlRGF0YTogYW55ID0ge1xuICAgICAgICAgIGJ1c2luZXNzX25hbWU6IGRhdGEuYnVzaW5lc3NfbmFtZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogZGF0YS5kZXNjcmlwdGlvbixcbiAgICAgICAgICBidXNpbmVzc19jYXRlZ29yeTogZGF0YS5idXNpbmVzc19jYXRlZ29yeSBhcyBhbnksXG4gICAgICAgICAgZXZlbnRfdHlwZXM6IGRhdGEuZXZlbnRfdHlwZXMgYXMgYW55LFxuICAgICAgICAgIGxvZ29fdXJsOiBkYXRhLmxvZ29fdXJsLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocHJvZmlsZS5idXNpbmVzc19uYW1lICE9PSBkYXRhLmJ1c2luZXNzX25hbWUpIHtcbiAgICAgICAgICAvLyBCdXNpbmVzcyBuYW1lIGNoYW5nZWQsIHJlZ2VuZXJhdGUgc2x1Z1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGdlbmVyYXRlVW5pcXVlU2x1ZyB9ID0gYXdhaXQgaW1wb3J0KFwiQC9saWIvc2x1Zy11dGlsc1wiKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NsdWcgPSBhd2FpdCBnZW5lcmF0ZVVuaXF1ZVNsdWcoZGF0YS5idXNpbmVzc19uYW1lLCBwcm9maWxlLnNsdWcgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHVwZGF0ZURhdGEuc2x1ZyA9IG5ld1NsdWc7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgQnVzaW5lc3MgbmFtZSBjaGFuZ2VkLCByZWdlbmVyYXRpbmcgc2x1ZzogJHtuZXdTbHVnfWApO1xuICAgICAgICAgIH0gY2F0Y2ggKHNsdWdFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcmVnZW5lcmF0ZSBzbHVnLCBrZWVwaW5nIGV4aXN0aW5nIHNsdWc6Jywgc2x1Z0Vycm9yKTtcbiAgICAgICAgICAgIC8vIEtlZXAgZXhpc3Rpbmcgc2x1ZyBvciBkb24ndCB1cGRhdGUgaXRcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGRhdGE6IHVwZGF0ZVJlc3VsdCwgZXJyb3I6IHByb2ZpbGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbShcInZlbmRvcl9wcm9maWxlc1wiKVxuICAgICAgICAgIC51cGRhdGUodXBkYXRlRGF0YSlcbiAgICAgICAgICAuZXEoXCJpZFwiLCBwcm9maWxlLmlkKVxuICAgICAgICAgIC5zZWxlY3QoKTtcblxuICAgICAgICBpZiAocHJvZmlsZUVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkZhaWxlZCB0byB1cGRhdGUgcHJvZmlsZVwiIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coXCLwn5eR77iPIERlbGV0aW5nIGV4aXN0aW5nIGNvbnRhY3RzIGFuZCBsb2NhdGlvbnMuLi5cIik7XG4gICAgICBcbiAgICAgIC8vIERlbGV0ZSBjb250YWN0cyBmaXJzdCAob25seSBpZiBwcm9maWxlIGV4aXN0ZWQgYmVmb3JlKVxuICAgICAgaWYgKHByb2ZpbGUpIHtcbiAgICAgICAgY29uc3QgeyBlcnJvcjogZGVsZXRlQ29udGFjdHNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbShcInZlbmRvcl9jb250YWN0c1wiKVxuICAgICAgICAgIC5kZWxldGUoKVxuICAgICAgICAgIC5lcShcInZlbmRvcl9pZFwiLCBwcm9maWxlLmlkKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk54gQ29udGFjdHMgZGVsZXRlIGVycm9yOlwiLCBkZWxldGVDb250YWN0c0Vycm9yKTtcblxuICAgICAgICBpZiAoZGVsZXRlQ29udGFjdHNFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwi4p2MIEZhaWxlZCB0byBkZWxldGUgY29udGFjdHM6XCIsIGRlbGV0ZUNvbnRhY3RzRXJyb3IpO1xuICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJGYWlsZWQgdG8gZGVsZXRlIGV4aXN0aW5nIGNvbnRhY3RzXCIgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwi4pyFIENvbnRhY3RzIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgICBcbiAgICAgICAgLy8gRGVsZXRlIGxvY2F0aW9uc1xuICAgICAgICBjb25zdCB7IGVycm9yOiBkZWxldGVMb2NhdGlvbnNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbShcInZlbmRvcl9sb2NhdGlvbnNcIilcbiAgICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgICAuZXEoXCJ2ZW5kb3JfaWRcIiwgcHJvZmlsZS5pZCk7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCLwn5ONIExvY2F0aW9ucyBkZWxldGUgZXJyb3I6XCIsIGRlbGV0ZUxvY2F0aW9uc0Vycm9yKTtcblxuICAgICAgICBpZiAoZGVsZXRlTG9jYXRpb25zRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIuKdjCBGYWlsZWQgdG8gZGVsZXRlIGxvY2F0aW9uczpcIiwgZGVsZXRlTG9jYXRpb25zRXJyb3IpO1xuICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJGYWlsZWQgdG8gZGVsZXRlIGV4aXN0aW5nIGxvY2F0aW9uc1wiIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBMb2NhdGlvbnMgZGVsZXRlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKFwi8J+TniBJbnNlcnRpbmcgbmV3IGNvbnRhY3RzLi4uXCIpO1xuICAgICAgXG4gICAgICAvLyBJbnNlcnQgbmV3IGNvbnRhY3RzXG4gICAgICBpZiAoZGF0YS5jb250YWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+TiyBDb250YWN0cyB0byBpbnNlcnQ6XCIsIGRhdGEuY29udGFjdHMpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgeyBlcnJvcjogY29udGFjdHNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbShcInZlbmRvcl9jb250YWN0c1wiKVxuICAgICAgICAgIC5pbnNlcnQoXG4gICAgICAgICAgICBkYXRhLmNvbnRhY3RzLm1hcCgoY29udGFjdCkgPT4gKHtcbiAgICAgICAgICAgICAgdmVuZG9yX2lkOiB2ZW5kb3JQcm9maWxlSWQsXG4gICAgICAgICAgICAgIGNvbnRhY3RfdHlwZTogY29udGFjdC5jb250YWN0X3R5cGUsXG4gICAgICAgICAgICAgIGNvbnRhY3RfdmFsdWU6IGNvbnRhY3QuY29udGFjdF92YWx1ZSxcbiAgICAgICAgICAgICAgaXNfcHJpbWFyeTogY29udGFjdC5pc19wcmltYXJ5LFxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk54gQ29udGFjdHMgaW5zZXJ0IGVycm9yOlwiLCBjb250YWN0c0Vycm9yKTtcblxuICAgICAgICBpZiAoY29udGFjdHNFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwi4p2MIEZhaWxlZCB0byBpbnNlcnQgY29udGFjdHM6XCIsIGNvbnRhY3RzRXJyb3IpO1xuICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJGYWlsZWQgdG8gdXBkYXRlIGNvbnRhY3RzXCIgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwi4pyFIENvbnRhY3RzIGluc2VydGVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwi4oS577iPIE5vIGNvbnRhY3RzIHRvIGluc2VydFwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coXCLwn5ONIEluc2VydGluZyBuZXcgbG9jYXRpb25zLi4uXCIpO1xuICAgICAgXG4gICAgICAvLyBJbnNlcnQgbmV3IGxvY2F0aW9uc1xuICAgICAgaWYgKGRhdGEubG9jYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5e677iPIExvY2F0aW9ucyB0byBpbnNlcnQ6XCIsIGRhdGEubG9jYXRpb25zKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFZhbGlkYXRlIGxvY2F0aW9uIHZhbHVlc1xuICAgICAgICBjb25zdCB2YWxpZExvY2F0aW9ucyA9IFtcbiAgICAgICAgICBcIm5pY29zaWFcIiwgXCJsaW1hc3NvbFwiLCBcImxhcm5hY2FcIiwgXCJwYXBob3NcIiwgXG4gICAgICAgICAgXCJwbGF0cmVzXCIsIFwicGFyYWxpbW5pX2F5aWFfbmFwYVwiLCBcIndob2xlX2N5cHJ1c1wiXG4gICAgICAgIF07XG4gICAgICAgIFxuICAgICAgICBjb25zdCBpbnZhbGlkTG9jYXRpb25zID0gZGF0YS5sb2NhdGlvbnMuZmlsdGVyKFxuICAgICAgICAgIGxvY2F0aW9uID0+ICF2YWxpZExvY2F0aW9ucy5pbmNsdWRlcyhsb2NhdGlvbilcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChpbnZhbGlkTG9jYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIuKdjCBJbnZhbGlkIGxvY2F0aW9uIHZhbHVlczpcIiwgaW52YWxpZExvY2F0aW9ucyk7XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBgSW52YWxpZCBsb2NhdGlvbiB2YWx1ZXM6ICR7aW52YWxpZExvY2F0aW9ucy5qb2luKFwiLCBcIil9YCB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBsb2NhdGlvbkRhdGEgPSBkYXRhLmxvY2F0aW9ucy5tYXAoKGxvY2F0aW9uKSA9PiAoe1xuICAgICAgICAgIHZlbmRvcl9pZDogdmVuZG9yUHJvZmlsZUlkLFxuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgfSkpO1xuICBcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5e677iPIExvY2F0aW9uIGRhdGEgdG8gaW5zZXJ0OlwiLCBsb2NhdGlvbkRhdGEpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgeyBkYXRhOiBpbnNlcnRlZExvY2F0aW9ucywgZXJyb3I6IGxvY2F0aW9uc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKFwidmVuZG9yX2xvY2F0aW9uc1wiKVxuICAgICAgICAgIC5pbnNlcnQobG9jYXRpb25EYXRhKVxuICAgICAgICAgIC5zZWxlY3QoKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk40gTG9jYXRpb25zIGluc2VydCBlcnJvcjpcIiwgbG9jYXRpb25zRXJyb3IpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk40gSW5zZXJ0ZWQgbG9jYXRpb25zOlwiLCBpbnNlcnRlZExvY2F0aW9ucyk7XG5cbiAgICAgICAgaWYgKGxvY2F0aW9uc0Vycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCLinYwgRmFpbGVkIHRvIGluc2VydCBsb2NhdGlvbnM6XCIsIGxvY2F0aW9uc0Vycm9yKTtcbiAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiRmFpbGVkIHRvIHVwZGF0ZSBsb2NhdGlvbnNcIiB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBMb2NhdGlvbnMgaW5zZXJ0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCLihLnvuI8gTm8gbG9jYXRpb25zIHRvIGluc2VydFwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coXCLwn5SEIFJlZmV0Y2hpbmcgcHJvZmlsZSBkYXRhLi4uXCIpO1xuICAgICAgXG4gICAgICAvLyBSZWZldGNoIGRhdGEgdG8gdXBkYXRlIHRoZSBVSVxuICAgICAgYXdhaXQgZmV0Y2hQcm9maWxlKCk7XG5cbiAgICAgIGNvbnNvbGUubG9nKFwi8J+OiSBQcm9maWxlIHNhdmUgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSFcIik7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIvCfkqUgRXhjZXB0aW9uIGluIHNhdmVQcm9maWxlOlwiLCBlcnIpO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWRcIiB9O1xuICAgIH1cbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGZldGNoUHJvZmlsZSgpO1xuICB9LCBbdXNlcl0pO1xuXG4gIHJldHVybiB7XG4gICAgcHJvZmlsZSxcbiAgICBjb250YWN0cyxcbiAgICBsb2NhdGlvbnMsXG4gICAgbG9hZGluZyxcbiAgICBlcnJvcixcbiAgICByZWZldGNoOiBmZXRjaFByb2ZpbGUsXG4gICAgc2F2ZVByb2ZpbGUsXG4gIH07XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VBdXRoIiwiY3JlYXRlQ2xpZW50Q29tcG9uZW50Q2xpZW50IiwidXNlVmVuZG9yUHJvZmlsZSIsInVzZXIiLCJwcm9maWxlIiwic2V0UHJvZmlsZSIsImNvbnRhY3RzIiwic2V0Q29udGFjdHMiLCJsb2NhdGlvbnMiLCJzZXRMb2NhdGlvbnMiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJmZXRjaFByb2ZpbGUiLCJzdXBhYmFzZSIsImRhdGEiLCJ1c2VyUHJvZmlsZSIsInVzZXJQcm9maWxlRXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJpZCIsInNpbmdsZSIsImNvbnNvbGUiLCJ1c2VyX3R5cGUiLCJsb2ciLCJwcm9maWxlRGF0YSIsInByb2ZpbGVFcnJvciIsIm1heFJldHJpZXMiLCJyZXRyeURlbGF5IiwiYXR0ZW1wdCIsImNvZGUiLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJKU09OIiwic3RyaW5naWZ5IiwiY29udGFjdHNEYXRhIiwiY29udGFjdHNFcnJvciIsIm9yZGVyIiwiYXNjZW5kaW5nIiwibG9jYXRpb25zRGF0YSIsImxvY2F0aW9uc0Vycm9yIiwiZXJyIiwic2F2ZVByb2ZpbGUiLCJzdWNjZXNzIiwidmVuZG9yUHJvZmlsZUlkIiwic2x1ZyIsImdlbmVyYXRlVW5pcXVlU2x1ZyIsImJ1c2luZXNzX25hbWUiLCJzbHVnRXJyb3IiLCJ3YXJuIiwibmV3UHJvZmlsZSIsImNyZWF0ZUVycm9yIiwiaW5zZXJ0IiwidXNlcl9pZCIsImRlc2NyaXB0aW9uIiwiYnVzaW5lc3NfY2F0ZWdvcnkiLCJldmVudF90eXBlcyIsImxvZ29fdXJsIiwidXBkYXRlRGF0YSIsInVwZGF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJuZXdTbHVnIiwidW5kZWZpbmVkIiwidXBkYXRlUmVzdWx0IiwidXBkYXRlIiwiZGVsZXRlQ29udGFjdHNFcnJvciIsImRlbGV0ZSIsImRlbGV0ZUxvY2F0aW9uc0Vycm9yIiwibGVuZ3RoIiwibWFwIiwiY29udGFjdCIsInZlbmRvcl9pZCIsImNvbnRhY3RfdHlwZSIsImNvbnRhY3RfdmFsdWUiLCJpc19wcmltYXJ5IiwidmFsaWRMb2NhdGlvbnMiLCJpbnZhbGlkTG9jYXRpb25zIiwiZmlsdGVyIiwibG9jYXRpb24iLCJqb2luIiwibG9jYXRpb25EYXRhIiwiaW5zZXJ0ZWRMb2NhdGlvbnMiLCJyZWZldGNoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useVendorProfile.ts\n"));

/***/ })

});